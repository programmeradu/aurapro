"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["common"],{

/***/ "(app-pages-browser)/./src/lib/memoryLeakFixes.ts":
/*!************************************!*\
  !*** ./src/lib/memoryLeakFixes.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MemoryLeakDetector: () => (/* binding */ MemoryLeakDetector),\n/* harmony export */   VehicleDataManager: () => (/* binding */ VehicleDataManager),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   initializeMemoryLeakPrevention: () => (/* binding */ initializeMemoryLeakPrevention),\n/* harmony export */   useMemoryLeakPrevention: () => (/* binding */ useMemoryLeakPrevention)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * 🧠 Memory Leak Prevention and Fixes\n * Comprehensive memory management for AURA Command Center\n */ \n// Memory leak detection and prevention utilities\nclass MemoryLeakDetector {\n    static getInstance() {\n        if (!MemoryLeakDetector.instance) {\n            MemoryLeakDetector.instance = new MemoryLeakDetector();\n        }\n        return MemoryLeakDetector.instance;\n    }\n    // Track intervals to prevent leaks\n    trackInterval(interval) {\n        this.intervals.add(interval);\n        return interval;\n    }\n    // Track timeouts to prevent leaks\n    trackTimeout(timeout) {\n        this.timeouts.add(timeout);\n        return timeout;\n    }\n    // Track event listeners\n    trackEventListener(target, event, listener) {\n        if (!this.eventListeners.has(target)) {\n            this.eventListeners.set(target, new Map());\n        }\n        this.eventListeners.get(target).set(event, listener);\n    }\n    // Track observers\n    trackObserver(observer) {\n        this.observers.add(observer);\n    }\n    // Track abort controllers\n    trackAbortController(controller) {\n        this.abortControllers.add(controller);\n        return controller;\n    }\n    // Clear specific interval\n    clearInterval(interval) {\n        clearInterval(interval);\n        this.intervals.delete(interval);\n    }\n    // Clear specific timeout\n    clearTimeout(timeout) {\n        clearTimeout(timeout);\n        this.timeouts.delete(timeout);\n    }\n    // Remove event listener\n    removeEventListener(target, event) {\n        const listeners = this.eventListeners.get(target);\n        if (listeners) {\n            const listener = listeners.get(event);\n            if (listener) {\n                target.removeEventListener(event, listener);\n                listeners.delete(event);\n                if (listeners.size === 0) {\n                    this.eventListeners.delete(target);\n                }\n            }\n        }\n    }\n    // Disconnect observer\n    disconnectObserver(observer) {\n        observer.disconnect();\n        this.observers.delete(observer);\n    }\n    // Abort controller\n    abortController(controller) {\n        controller.abort();\n        this.abortControllers.delete(controller);\n    }\n    // Clean up all tracked resources\n    cleanupAll() {\n        console.log('🧹 Cleaning up all tracked resources...');\n        // Clear all intervals\n        this.intervals.forEach((interval)=>clearInterval(interval));\n        this.intervals.clear();\n        // Clear all timeouts\n        this.timeouts.forEach((timeout)=>clearTimeout(timeout));\n        this.timeouts.clear();\n        // Remove all event listeners\n        this.eventListeners.forEach((listeners, target)=>{\n            listeners.forEach((listener, event)=>{\n                target.removeEventListener(event, listener);\n            });\n        });\n        this.eventListeners.clear();\n        // Disconnect all observers\n        this.observers.forEach((observer)=>observer.disconnect());\n        this.observers.clear();\n        // Abort all controllers\n        this.abortControllers.forEach((controller)=>controller.abort());\n        this.abortControllers.clear();\n        // Stop memory monitoring\n        if (this.memoryMonitorInterval) {\n            clearInterval(this.memoryMonitorInterval);\n            this.memoryMonitorInterval = null;\n        }\n        console.log('✅ All resources cleaned up');\n    }\n    // Monitor memory usage\n    startMemoryMonitoring() {\n        if (this.memoryMonitorInterval) return;\n        this.memoryMonitorInterval = setInterval(()=>{\n            if ( true && 'performance' in window && 'memory' in window.performance) {\n                const memory = window.performance.memory;\n                const memoryUsage = {\n                    used: Math.round(memory.usedJSHeapSize / 1024 / 1024),\n                    total: Math.round(memory.totalJSHeapSize / 1024 / 1024),\n                    limit: Math.round(memory.jsHeapSizeLimit / 1024 / 1024)\n                };\n                // Log warning if memory usage is high\n                if (memoryUsage.used > memoryUsage.limit * 0.8) {\n                    console.warn('⚠️ High memory usage detected:', memoryUsage);\n                    console.log('📊 Tracked resources:', {\n                        intervals: this.intervals.size,\n                        timeouts: this.timeouts.size,\n                        eventListeners: this.eventListeners.size,\n                        observers: this.observers.size,\n                        abortControllers: this.abortControllers.size\n                    });\n                }\n            }\n        }, 30000) // Check every 30 seconds\n        ;\n    }\n    // Get memory usage statistics\n    getMemoryStats() {\n        if ( true && 'performance' in window && 'memory' in window.performance) {\n            const memory = window.performance.memory;\n            return {\n                used: Math.round(memory.usedJSHeapSize / 1024 / 1024),\n                total: Math.round(memory.totalJSHeapSize / 1024 / 1024),\n                limit: Math.round(memory.jsHeapSizeLimit / 1024 / 1024),\n                trackedResources: {\n                    intervals: this.intervals.size,\n                    timeouts: this.timeouts.size,\n                    eventListeners: this.eventListeners.size,\n                    observers: this.observers.size,\n                    abortControllers: this.abortControllers.size\n                }\n            };\n        }\n        return null;\n    }\n    constructor(){\n        this.intervals = new Set();\n        this.timeouts = new Set();\n        this.eventListeners = new Map();\n        this.observers = new Set();\n        this.abortControllers = new Set();\n        this.memoryMonitorInterval = null;\n    }\n}\n// React hooks for memory leak prevention\nconst useMemoryLeakPrevention = ()=>{\n    const detector = MemoryLeakDetector.getInstance();\n    const cleanupFunctions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const addCleanup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMemoryLeakPrevention.useCallback[addCleanup]\": (cleanup)=>{\n            cleanupFunctions.current.push(cleanup);\n        }\n    }[\"useMemoryLeakPrevention.useCallback[addCleanup]\"], []);\n    const safeSetInterval = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMemoryLeakPrevention.useCallback[safeSetInterval]\": (callback, delay)=>{\n            const interval = setInterval(callback, delay);\n            detector.trackInterval(interval);\n            addCleanup({\n                \"useMemoryLeakPrevention.useCallback[safeSetInterval]\": ()=>detector.clearInterval(interval)\n            }[\"useMemoryLeakPrevention.useCallback[safeSetInterval]\"]);\n            return interval;\n        }\n    }[\"useMemoryLeakPrevention.useCallback[safeSetInterval]\"], [\n        detector,\n        addCleanup\n    ]);\n    const safeSetTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMemoryLeakPrevention.useCallback[safeSetTimeout]\": (callback, delay)=>{\n            const timeout = setTimeout(callback, delay);\n            detector.trackTimeout(timeout);\n            addCleanup({\n                \"useMemoryLeakPrevention.useCallback[safeSetTimeout]\": ()=>detector.clearTimeout(timeout)\n            }[\"useMemoryLeakPrevention.useCallback[safeSetTimeout]\"]);\n            return timeout;\n        }\n    }[\"useMemoryLeakPrevention.useCallback[safeSetTimeout]\"], [\n        detector,\n        addCleanup\n    ]);\n    const safeAddEventListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMemoryLeakPrevention.useCallback[safeAddEventListener]\": (target, event, listener, options)=>{\n            target.addEventListener(event, listener, options);\n            detector.trackEventListener(target, event, listener);\n            addCleanup({\n                \"useMemoryLeakPrevention.useCallback[safeAddEventListener]\": ()=>detector.removeEventListener(target, event)\n            }[\"useMemoryLeakPrevention.useCallback[safeAddEventListener]\"]);\n        }\n    }[\"useMemoryLeakPrevention.useCallback[safeAddEventListener]\"], [\n        detector,\n        addCleanup\n    ]);\n    const safeCreateObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMemoryLeakPrevention.useCallback[safeCreateObserver]\": (observer)=>{\n            detector.trackObserver(observer);\n            addCleanup({\n                \"useMemoryLeakPrevention.useCallback[safeCreateObserver]\": ()=>detector.disconnectObserver(observer)\n            }[\"useMemoryLeakPrevention.useCallback[safeCreateObserver]\"]);\n            return observer;\n        }\n    }[\"useMemoryLeakPrevention.useCallback[safeCreateObserver]\"], [\n        detector,\n        addCleanup\n    ]);\n    const safeCreateAbortController = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMemoryLeakPrevention.useCallback[safeCreateAbortController]\": ()=>{\n            const controller = new AbortController();\n            detector.trackAbortController(controller);\n            addCleanup({\n                \"useMemoryLeakPrevention.useCallback[safeCreateAbortController]\": ()=>detector.abortController(controller)\n            }[\"useMemoryLeakPrevention.useCallback[safeCreateAbortController]\"]);\n            return controller;\n        }\n    }[\"useMemoryLeakPrevention.useCallback[safeCreateAbortController]\"], [\n        detector,\n        addCleanup\n    ]);\n    // Cleanup on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMemoryLeakPrevention.useEffect\": ()=>{\n            return ({\n                \"useMemoryLeakPrevention.useEffect\": ()=>{\n                    cleanupFunctions.current.forEach({\n                        \"useMemoryLeakPrevention.useEffect\": (cleanup)=>{\n                            try {\n                                cleanup();\n                            } catch (error) {\n                                console.warn('Error during cleanup:', error);\n                            }\n                        }\n                    }[\"useMemoryLeakPrevention.useEffect\"]);\n                    cleanupFunctions.current = [];\n                }\n            })[\"useMemoryLeakPrevention.useEffect\"];\n        }\n    }[\"useMemoryLeakPrevention.useEffect\"], []);\n    return {\n        safeSetInterval,\n        safeSetTimeout,\n        safeAddEventListener,\n        safeCreateObserver,\n        safeCreateAbortController,\n        addCleanup\n    };\n};\n// Vehicle data accumulation fix\nclass VehicleDataManager {\n    static getInstance() {\n        if (!VehicleDataManager.instance) {\n            VehicleDataManager.instance = new VehicleDataManager();\n        }\n        return VehicleDataManager.instance;\n    }\n    addVehicle(id, data) {\n        // Add timestamp for cleanup\n        this.vehicleData.set(id, {\n            ...data,\n            lastUpdate: Date.now()\n        });\n        // Prevent unlimited growth\n        if (this.vehicleData.size > this.maxVehicles) {\n            this.cleanupOldVehicles();\n        }\n    }\n    getVehicle(id) {\n        return this.vehicleData.get(id);\n    }\n    getAllVehicles() {\n        return Array.from(this.vehicleData.values());\n    }\n    removeVehicle(id) {\n        this.vehicleData.delete(id);\n    }\n    cleanupOldVehicles() {\n        const now = Date.now();\n        const maxAge = 5 * 60 * 1000 // 5 minutes\n        ;\n        for (const [id, data] of this.vehicleData.entries()){\n            if (now - data.lastUpdate > maxAge) {\n                this.vehicleData.delete(id);\n            }\n        }\n        console.log(\"\\uD83E\\uDDF9 Cleaned up old vehicles. Current count: \".concat(this.vehicleData.size));\n    }\n    startCleanup() {\n        if (this.cleanupInterval) return;\n        this.cleanupInterval = setInterval(()=>{\n            this.cleanupOldVehicles();\n        }, 60000) // Cleanup every minute\n        ;\n    }\n    destroy() {\n        if (this.cleanupInterval) {\n            clearInterval(this.cleanupInterval);\n            this.cleanupInterval = null;\n        }\n        this.vehicleData.clear();\n    }\n    constructor(){\n        this.vehicleData = new Map();\n        this.maxVehicles = 1000;\n        this.cleanupInterval = null;\n        this.startCleanup();\n    }\n}\n// Initialize memory leak prevention\nconst initializeMemoryLeakPrevention = ()=>{\n    const detector = MemoryLeakDetector.getInstance();\n    // Start memory monitoring\n    detector.startMemoryMonitoring();\n    // Clean up on page unload\n    if (true) {\n        window.addEventListener('beforeunload', ()=>{\n            detector.cleanupAll();\n            VehicleDataManager.getInstance().destroy();\n        });\n        // Clean up on visibility change (tab switch)\n        document.addEventListener('visibilitychange', ()=>{\n            if (document.hidden) {\n                // Perform cleanup when tab becomes hidden\n                detector.cleanupAll();\n            }\n        });\n    }\n    console.log('🧠 Memory leak prevention initialized');\n};\n// Export utilities\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    MemoryLeakDetector,\n    VehicleDataManager,\n    useMemoryLeakPrevention,\n    initializeMemoryLeakPrevention\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbWVtb3J5TGVha0ZpeGVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFcUQ7QUFFdEQsaURBQWlEO0FBQzFDLE1BQU1HO0lBU1gsT0FBT0MsY0FBa0M7UUFDdkMsSUFBSSxDQUFDRCxtQkFBbUJFLFFBQVEsRUFBRTtZQUNoQ0YsbUJBQW1CRSxRQUFRLEdBQUcsSUFBSUY7UUFDcEM7UUFDQSxPQUFPQSxtQkFBbUJFLFFBQVE7SUFDcEM7SUFFQSxtQ0FBbUM7SUFDbkNDLGNBQWNDLFFBQXdCLEVBQWtCO1FBQ3RELElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxHQUFHLENBQUNGO1FBQ25CLE9BQU9BO0lBQ1Q7SUFFQSxrQ0FBa0M7SUFDbENHLGFBQWFDLE9BQXVCLEVBQWtCO1FBQ3BELElBQUksQ0FBQ0MsUUFBUSxDQUFDSCxHQUFHLENBQUNFO1FBQ2xCLE9BQU9BO0lBQ1Q7SUFFQSx3QkFBd0I7SUFDeEJFLG1CQUFtQkMsTUFBbUIsRUFBRUMsS0FBYSxFQUFFQyxRQUF1QixFQUFRO1FBQ3BGLElBQUksQ0FBQyxJQUFJLENBQUNDLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDSixTQUFTO1lBQ3BDLElBQUksQ0FBQ0csY0FBYyxDQUFDRSxHQUFHLENBQUNMLFFBQVEsSUFBSU07UUFDdEM7UUFDQSxJQUFJLENBQUNILGNBQWMsQ0FBQ0ksR0FBRyxDQUFDUCxRQUFTSyxHQUFHLENBQUNKLE9BQU9DO0lBQzlDO0lBRUEsa0JBQWtCO0lBQ2xCTSxjQUFjQyxRQUFrRSxFQUFRO1FBQ3RGLElBQUksQ0FBQ0MsU0FBUyxDQUFDZixHQUFHLENBQUNjO0lBQ3JCO0lBRUEsMEJBQTBCO0lBQzFCRSxxQkFBcUJDLFVBQTJCLEVBQW1CO1FBQ2pFLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNsQixHQUFHLENBQUNpQjtRQUMxQixPQUFPQTtJQUNUO0lBRUEsMEJBQTBCO0lBQzFCRSxjQUFjckIsUUFBd0IsRUFBUTtRQUM1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Qjs7SUFDbkM7SUFFQVcsVUFBZ0I7UUFDZCxJQUFJLElBQUksQ0FBQ0QsZUFBZSxFQUFFO1lBQ3hCeEUsY0FBYyxJQUFJLENBQUN3RSxlQUFlO1lBQ2xDLElBQUksQ0FBQ0EsZUFBZSxHQUFHO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDZixXQUFXLENBQUMzQyxLQUFLO0lBQ3hCO0lBeERBNEQsYUFBYzthQVhOakIsY0FBZ0MsSUFBSWpFO2FBQ3BDcUUsY0FBc0I7YUFDdEJXLGtCQUF5QztRQVUvQyxJQUFJLENBQUNELFlBQVk7SUFDbkI7QUF1REY7QUFFQSxvQ0FBb0M7QUFDN0IsTUFBTUksaUNBQWlDO0lBQzVDLE1BQU14QyxXQUFXNUQsbUJBQW1CQyxXQUFXO0lBRS9DLDBCQUEwQjtJQUMxQjJELFNBQVNuQixxQkFBcUI7SUFFOUIsMEJBQTBCO0lBQzFCLElBQUksSUFBNkIsRUFBRTtRQUNqQ0UsT0FBTzhCLGdCQUFnQixDQUFDLGdCQUFnQjtZQUN0Q2IsU0FBU3pCLFVBQVU7WUFDbkIyQyxtQkFBbUI3RSxXQUFXLEdBQUdpRyxPQUFPO1FBQzFDO1FBRUEsNkNBQTZDO1FBQzdDRyxTQUFTNUIsZ0JBQWdCLENBQUMsb0JBQW9CO1lBQzVDLElBQUk0QixTQUFTQyxNQUFNLEVBQUU7Z0JBQ25CLDBDQUEwQztnQkFDMUMxQyxTQUFTekIsVUFBVTtZQUNyQjtRQUNGO0lBQ0Y7SUFFQUMsUUFBUUMsR0FBRyxDQUFDO0FBQ2QsRUFBQztBQUVELG1CQUFtQjtBQUNuQixpRUFBZTtJQUNickM7SUFDQThFO0lBQ0FuQjtJQUNBeUM7QUFDRixDQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNhbVxcRGVza3RvcFxcYXVyYVxcc3JjXFxsaWJcXG1lbW9yeUxlYWtGaXhlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIPCfp6AgTWVtb3J5IExlYWsgUHJldmVudGlvbiBhbmQgRml4ZXNcbiAqIENvbXByZWhlbnNpdmUgbWVtb3J5IG1hbmFnZW1lbnQgZm9yIEFVUkEgQ29tbWFuZCBDZW50ZXJcbiAqL1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcblxuLy8gTWVtb3J5IGxlYWsgZGV0ZWN0aW9uIGFuZCBwcmV2ZW50aW9uIHV0aWxpdGllc1xuZXhwb3J0IGNsYXNzIE1lbW9yeUxlYWtEZXRlY3RvciB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBNZW1vcnlMZWFrRGV0ZWN0b3JcbiAgcHJpdmF0ZSBpbnRlcnZhbHM6IFNldDxOb2RlSlMuVGltZW91dD4gPSBuZXcgU2V0KClcbiAgcHJpdmF0ZSB0aW1lb3V0czogU2V0PE5vZGVKUy5UaW1lb3V0PiA9IG5ldyBTZXQoKVxuICBwcml2YXRlIGV2ZW50TGlzdGVuZXJzOiBNYXA8RXZlbnRUYXJnZXQsIE1hcDxzdHJpbmcsIEV2ZW50TGlzdGVuZXI+PiA9IG5ldyBNYXAoKVxuICBwcml2YXRlIG9ic2VydmVyczogU2V0PEludGVyc2VjdGlvbk9ic2VydmVyIHwgTXV0YXRpb25PYnNlcnZlciB8IFJlc2l6ZU9ic2VydmVyPiA9IG5ldyBTZXQoKVxuICBwcml2YXRlIGFib3J0Q29udHJvbGxlcnM6IFNldDxBYm9ydENvbnRyb2xsZXI+ID0gbmV3IFNldCgpXG4gIHByaXZhdGUgbWVtb3J5TW9uaXRvckludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsXG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IE1lbW9yeUxlYWtEZXRlY3RvciB7XG4gICAgaWYgKCFNZW1vcnlMZWFrRGV0ZWN0b3IuaW5zdGFuY2UpIHtcbiAgICAgIE1lbW9yeUxlYWtEZXRlY3Rvci5pbnN0YW5jZSA9IG5ldyBNZW1vcnlMZWFrRGV0ZWN0b3IoKVxuICAgIH1cbiAgICByZXR1cm4gTWVtb3J5TGVha0RldGVjdG9yLmluc3RhbmNlXG4gIH1cblxuICAvLyBUcmFjayBpbnRlcnZhbHMgdG8gcHJldmVudCBsZWFrc1xuICB0cmFja0ludGVydmFsKGludGVydmFsOiBOb2RlSlMuVGltZW91dCk6IE5vZGVKUy5UaW1lb3V0IHtcbiAgICB0aGlzLmludGVydmFscy5hZGQoaW50ZXJ2YWwpXG4gICAgcmV0dXJuIGludGVydmFsXG4gIH1cblxuICAvLyBUcmFjayB0aW1lb3V0cyB0byBwcmV2ZW50IGxlYWtzXG4gIHRyYWNrVGltZW91dCh0aW1lb3V0OiBOb2RlSlMuVGltZW91dCk6IE5vZGVKUy5UaW1lb3V0IHtcbiAgICB0aGlzLnRpbWVvdXRzLmFkZCh0aW1lb3V0KVxuICAgIHJldHVybiB0aW1lb3V0XG4gIH1cblxuICAvLyBUcmFjayBldmVudCBsaXN0ZW5lcnNcbiAgdHJhY2tFdmVudExpc3RlbmVyKHRhcmdldDogRXZlbnRUYXJnZXQsIGV2ZW50OiBzdHJpbmcsIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmV2ZW50TGlzdGVuZXJzLmhhcyh0YXJnZXQpKSB7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNldCh0YXJnZXQsIG5ldyBNYXAoKSlcbiAgICB9XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5nZXQodGFyZ2V0KSEuc2V0KGV2ZW50LCBsaXN0ZW5lcilcbiAgfVxuXG4gIC8vIFRyYWNrIG9ic2VydmVyc1xuICB0cmFja09ic2VydmVyKG9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlciB8IE11dGF0aW9uT2JzZXJ2ZXIgfCBSZXNpemVPYnNlcnZlcik6IHZvaWQge1xuICAgIHRoaXMub2JzZXJ2ZXJzLmFkZChvYnNlcnZlcilcbiAgfVxuXG4gIC8vIFRyYWNrIGFib3J0IGNvbnRyb2xsZXJzXG4gIHRyYWNrQWJvcnRDb250cm9sbGVyKGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcik6IEFib3J0Q29udHJvbGxlciB7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzLmFkZChjb250cm9sbGVyKVxuICAgIHJldHVybiBjb250cm9sbGVyXG4gIH1cblxuICAvLyBDbGVhciBzcGVjaWZpYyBpbnRlcnZhbFxuICBjbGVhckludGVydmFsKGludGVydmFsOiBOb2RlSlMuVGltZW91dCk6IHZvaWQge1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpXG4gICAgdGhpcy5pbnRlcnZhbHMuZGVsZXRlKGludGVydmFsKVxuICB9XG5cbiAgLy8gQ2xlYXIgc3BlY2lmaWMgdGltZW91dFxuICBjbGVhclRpbWVvdXQodGltZW91dDogTm9kZUpTLlRpbWVvdXQpOiB2b2lkIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICB0aGlzLnRpbWVvdXRzLmRlbGV0ZSh0aW1lb3V0KVxuICB9XG5cbiAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodGFyZ2V0OiBFdmVudFRhcmdldCwgZXZlbnQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KHRhcmdldClcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVycy5nZXQoZXZlbnQpXG4gICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKVxuICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50KVxuICAgICAgICBpZiAobGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmRlbGV0ZSh0YXJnZXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBEaXNjb25uZWN0IG9ic2VydmVyXG4gIGRpc2Nvbm5lY3RPYnNlcnZlcihvYnNlcnZlcjogSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgfCBNdXRhdGlvbk9ic2VydmVyIHwgUmVzaXplT2JzZXJ2ZXIpOiB2b2lkIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICB0aGlzLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpXG4gIH1cblxuICAvLyBBYm9ydCBjb250cm9sbGVyXG4gIGFib3J0Q29udHJvbGxlcihjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpOiB2b2lkIHtcbiAgICBjb250cm9sbGVyLmFib3J0KClcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlcnMuZGVsZXRlKGNvbnRyb2xsZXIpXG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbGwgdHJhY2tlZCByZXNvdXJjZXNcbiAgY2xlYW51cEFsbCgpOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZygn8J+nuSBDbGVhbmluZyB1cCBhbGwgdHJhY2tlZCByZXNvdXJjZXMuLi4nKVxuXG4gICAgLy8gQ2xlYXIgYWxsIGludGVydmFsc1xuICAgIHRoaXMuaW50ZXJ2YWxzLmZvckVhY2goaW50ZXJ2YWwgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCkpXG4gICAgdGhpcy5pbnRlcnZhbHMuY2xlYXIoKVxuXG4gICAgLy8gQ2xlYXIgYWxsIHRpbWVvdXRzXG4gICAgdGhpcy50aW1lb3V0cy5mb3JFYWNoKHRpbWVvdXQgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpKVxuICAgIHRoaXMudGltZW91dHMuY2xlYXIoKVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVycywgdGFyZ2V0KSA9PiB7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIsIGV2ZW50KSA9PiB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcilcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmNsZWFyKClcblxuICAgIC8vIERpc2Nvbm5lY3QgYWxsIG9ic2VydmVyc1xuICAgIHRoaXMub2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpKVxuICAgIHRoaXMub2JzZXJ2ZXJzLmNsZWFyKClcblxuICAgIC8vIEFib3J0IGFsbCBjb250cm9sbGVyc1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4gY29udHJvbGxlci5hYm9ydCgpKVxuICAgIHRoaXMuYWJvcnRDb250cm9sbGVycy5jbGVhcigpXG5cbiAgICAvLyBTdG9wIG1lbW9yeSBtb25pdG9yaW5nXG4gICAgaWYgKHRoaXMubWVtb3J5TW9uaXRvckludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMubWVtb3J5TW9uaXRvckludGVydmFsKVxuICAgICAgdGhpcy5tZW1vcnlNb25pdG9ySW50ZXJ2YWwgPSBudWxsXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ+KchSBBbGwgcmVzb3VyY2VzIGNsZWFuZWQgdXAnKVxuICB9XG5cbiAgLy8gTW9uaXRvciBtZW1vcnkgdXNhZ2VcbiAgc3RhcnRNZW1vcnlNb25pdG9yaW5nKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1lbW9yeU1vbml0b3JJbnRlcnZhbCkgcmV0dXJuXG5cbiAgICB0aGlzLm1lbW9yeU1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAncGVyZm9ybWFuY2UnIGluIHdpbmRvdyAmJiAnbWVtb3J5JyBpbiAod2luZG93LnBlcmZvcm1hbmNlIGFzIGFueSkpIHtcbiAgICAgICAgY29uc3QgbWVtb3J5ID0gKHdpbmRvdy5wZXJmb3JtYW5jZSBhcyBhbnkpLm1lbW9yeVxuICAgICAgICBjb25zdCBtZW1vcnlVc2FnZSA9IHtcbiAgICAgICAgICB1c2VkOiBNYXRoLnJvdW5kKG1lbW9yeS51c2VkSlNIZWFwU2l6ZSAvIDEwMjQgLyAxMDI0KSxcbiAgICAgICAgICB0b3RhbDogTWF0aC5yb3VuZChtZW1vcnkudG90YWxKU0hlYXBTaXplIC8gMTAyNCAvIDEwMjQpLFxuICAgICAgICAgIGxpbWl0OiBNYXRoLnJvdW5kKG1lbW9yeS5qc0hlYXBTaXplTGltaXQgLyAxMDI0IC8gMTAyNClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvZyB3YXJuaW5nIGlmIG1lbW9yeSB1c2FnZSBpcyBoaWdoXG4gICAgICAgIGlmIChtZW1vcnlVc2FnZS51c2VkID4gbWVtb3J5VXNhZ2UubGltaXQgKiAwLjgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBIaWdoIG1lbW9yeSB1c2FnZSBkZXRlY3RlZDonLCBtZW1vcnlVc2FnZSlcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBUcmFja2VkIHJlc291cmNlczonLCB7XG4gICAgICAgICAgICBpbnRlcnZhbHM6IHRoaXMuaW50ZXJ2YWxzLnNpemUsXG4gICAgICAgICAgICB0aW1lb3V0czogdGhpcy50aW1lb3V0cy5zaXplLFxuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcnM6IHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2l6ZSxcbiAgICAgICAgICAgIG9ic2VydmVyczogdGhpcy5vYnNlcnZlcnMuc2l6ZSxcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcnM6IHRoaXMuYWJvcnRDb250cm9sbGVycy5zaXplXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDMwMDAwKSAvLyBDaGVjayBldmVyeSAzMCBzZWNvbmRzXG4gIH1cblxuICAvLyBHZXQgbWVtb3J5IHVzYWdlIHN0YXRpc3RpY3NcbiAgZ2V0TWVtb3J5U3RhdHMoKTogYW55IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3BlcmZvcm1hbmNlJyBpbiB3aW5kb3cgJiYgJ21lbW9yeScgaW4gKHdpbmRvdy5wZXJmb3JtYW5jZSBhcyBhbnkpKSB7XG4gICAgICBjb25zdCBtZW1vcnkgPSAod2luZG93LnBlcmZvcm1hbmNlIGFzIGFueSkubWVtb3J5XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1c2VkOiBNYXRoLnJvdW5kKG1lbW9yeS51c2VkSlNIZWFwU2l6ZSAvIDEwMjQgLyAxMDI0KSxcbiAgICAgICAgdG90YWw6IE1hdGgucm91bmQobWVtb3J5LnRvdGFsSlNIZWFwU2l6ZSAvIDEwMjQgLyAxMDI0KSxcbiAgICAgICAgbGltaXQ6IE1hdGgucm91bmQobWVtb3J5LmpzSGVhcFNpemVMaW1pdCAvIDEwMjQgLyAxMDI0KSxcbiAgICAgICAgdHJhY2tlZFJlc291cmNlczoge1xuICAgICAgICAgIGludGVydmFsczogdGhpcy5pbnRlcnZhbHMuc2l6ZSxcbiAgICAgICAgICB0aW1lb3V0czogdGhpcy50aW1lb3V0cy5zaXplLFxuICAgICAgICAgIGV2ZW50TGlzdGVuZXJzOiB0aGlzLmV2ZW50TGlzdGVuZXJzLnNpemUsXG4gICAgICAgICAgb2JzZXJ2ZXJzOiB0aGlzLm9ic2VydmVycy5zaXplLFxuICAgICAgICAgIGFib3J0Q29udHJvbGxlcnM6IHRoaXMuYWJvcnRDb250cm9sbGVycy5zaXplXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vLyBSZWFjdCBob29rcyBmb3IgbWVtb3J5IGxlYWsgcHJldmVudGlvblxuZXhwb3J0IGNvbnN0IHVzZU1lbW9yeUxlYWtQcmV2ZW50aW9uID0gKCkgPT4ge1xuICBjb25zdCBkZXRlY3RvciA9IE1lbW9yeUxlYWtEZXRlY3Rvci5nZXRJbnN0YW5jZSgpXG4gIGNvbnN0IGNsZWFudXBGdW5jdGlvbnMgPSB1c2VSZWY8KCgpID0+IHZvaWQpW10+KFtdKVxuXG4gIGNvbnN0IGFkZENsZWFudXAgPSB1c2VDYWxsYmFjaygoY2xlYW51cDogKCkgPT4gdm9pZCkgPT4ge1xuICAgIGNsZWFudXBGdW5jdGlvbnMuY3VycmVudC5wdXNoKGNsZWFudXApXG4gIH0sIFtdKVxuXG4gIGNvbnN0IHNhZmVTZXRJbnRlcnZhbCA9IHVzZUNhbGxiYWNrKChjYWxsYmFjazogKCkgPT4gdm9pZCwgZGVsYXk6IG51bWJlcik6IE5vZGVKUy5UaW1lb3V0ID0+IHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKGNhbGxiYWNrLCBkZWxheSlcbiAgICBkZXRlY3Rvci50cmFja0ludGVydmFsKGludGVydmFsKVxuICAgIGFkZENsZWFudXAoKCkgPT4gZGV0ZWN0b3IuY2xlYXJJbnRlcnZhbChpbnRlcnZhbCkpXG4gICAgcmV0dXJuIGludGVydmFsXG4gIH0sIFtkZXRlY3RvciwgYWRkQ2xlYW51cF0pXG5cbiAgY29uc3Qgc2FmZVNldFRpbWVvdXQgPSB1c2VDYWxsYmFjaygoY2FsbGJhY2s6ICgpID0+IHZvaWQsIGRlbGF5OiBudW1iZXIpOiBOb2RlSlMuVGltZW91dCA9PiB7XG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KVxuICAgIGRldGVjdG9yLnRyYWNrVGltZW91dCh0aW1lb3V0KVxuICAgIGFkZENsZWFudXAoKCkgPT4gZGV0ZWN0b3IuY2xlYXJUaW1lb3V0KHRpbWVvdXQpKVxuICAgIHJldHVybiB0aW1lb3V0XG4gIH0sIFtkZXRlY3RvciwgYWRkQ2xlYW51cF0pXG5cbiAgY29uc3Qgc2FmZUFkZEV2ZW50TGlzdGVuZXIgPSB1c2VDYWxsYmFjaygoXG4gICAgdGFyZ2V0OiBFdmVudFRhcmdldCxcbiAgICBldmVudDogc3RyaW5nLFxuICAgIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyLFxuICAgIG9wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnNcbiAgKSA9PiB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zKVxuICAgIGRldGVjdG9yLnRyYWNrRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lcilcbiAgICBhZGRDbGVhbnVwKCgpID0+IGRldGVjdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudCkpXG4gIH0sIFtkZXRlY3RvciwgYWRkQ2xlYW51cF0pXG5cbiAgY29uc3Qgc2FmZUNyZWF0ZU9ic2VydmVyID0gdXNlQ2FsbGJhY2soPFQgZXh0ZW5kcyBJbnRlcnNlY3Rpb25PYnNlcnZlciB8IE11dGF0aW9uT2JzZXJ2ZXIgfCBSZXNpemVPYnNlcnZlcj4oXG4gICAgb2JzZXJ2ZXI6IFRcbiAgKTogVCA9PiB7XG4gICAgZGV0ZWN0b3IudHJhY2tPYnNlcnZlcihvYnNlcnZlcilcbiAgICBhZGRDbGVhbnVwKCgpID0+IGRldGVjdG9yLmRpc2Nvbm5lY3RPYnNlcnZlcihvYnNlcnZlcikpXG4gICAgcmV0dXJuIG9ic2VydmVyXG4gIH0sIFtkZXRlY3RvciwgYWRkQ2xlYW51cF0pXG5cbiAgY29uc3Qgc2FmZUNyZWF0ZUFib3J0Q29udHJvbGxlciA9IHVzZUNhbGxiYWNrKCgpOiBBYm9ydENvbnRyb2xsZXIgPT4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBkZXRlY3Rvci50cmFja0Fib3J0Q29udHJvbGxlcihjb250cm9sbGVyKVxuICAgIGFkZENsZWFudXAoKCkgPT4gZGV0ZWN0b3IuYWJvcnRDb250cm9sbGVyKGNvbnRyb2xsZXIpKVxuICAgIHJldHVybiBjb250cm9sbGVyXG4gIH0sIFtkZXRlY3RvciwgYWRkQ2xlYW51cF0pXG5cbiAgLy8gQ2xlYW51cCBvbiB1bm1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXBGdW5jdGlvbnMuY3VycmVudC5mb3JFYWNoKGNsZWFudXAgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXAoKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgZHVyaW5nIGNsZWFudXA6JywgZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBjbGVhbnVwRnVuY3Rpb25zLmN1cnJlbnQgPSBbXVxuICAgIH1cbiAgfSwgW10pXG5cbiAgcmV0dXJuIHtcbiAgICBzYWZlU2V0SW50ZXJ2YWwsXG4gICAgc2FmZVNldFRpbWVvdXQsXG4gICAgc2FmZUFkZEV2ZW50TGlzdGVuZXIsXG4gICAgc2FmZUNyZWF0ZU9ic2VydmVyLFxuICAgIHNhZmVDcmVhdGVBYm9ydENvbnRyb2xsZXIsXG4gICAgYWRkQ2xlYW51cFxuICB9XG59XG5cbi8vIFZlaGljbGUgZGF0YSBhY2N1bXVsYXRpb24gZml4XG5leHBvcnQgY2xhc3MgVmVoaWNsZURhdGFNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFZlaGljbGVEYXRhTWFuYWdlclxuICBwcml2YXRlIHZlaGljbGVEYXRhOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcCgpXG4gIHByaXZhdGUgbWF4VmVoaWNsZXM6IG51bWJlciA9IDEwMDBcbiAgcHJpdmF0ZSBjbGVhbnVwSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGxcblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogVmVoaWNsZURhdGFNYW5hZ2VyIHtcbiAgICBpZiAoIVZlaGljbGVEYXRhTWFuYWdlci5pbnN0YW5jZSkge1xuICAgICAgVmVoaWNsZURhdGFNYW5hZ2VyLmluc3RhbmNlID0gbmV3IFZlaGljbGVEYXRhTWFuYWdlcigpXG4gICAgfVxuICAgIHJldHVybiBWZWhpY2xlRGF0YU1hbmFnZXIuaW5zdGFuY2VcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhcnRDbGVhbnVwKClcbiAgfVxuXG4gIGFkZFZlaGljbGUoaWQ6IHN0cmluZywgZGF0YTogYW55KTogdm9pZCB7XG4gICAgLy8gQWRkIHRpbWVzdGFtcCBmb3IgY2xlYW51cFxuICAgIHRoaXMudmVoaWNsZURhdGEuc2V0KGlkLCB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgbGFzdFVwZGF0ZTogRGF0ZS5ub3coKVxuICAgIH0pXG5cbiAgICAvLyBQcmV2ZW50IHVubGltaXRlZCBncm93dGhcbiAgICBpZiAodGhpcy52ZWhpY2xlRGF0YS5zaXplID4gdGhpcy5tYXhWZWhpY2xlcykge1xuICAgICAgdGhpcy5jbGVhbnVwT2xkVmVoaWNsZXMoKVxuICAgIH1cbiAgfVxuXG4gIGdldFZlaGljbGUoaWQ6IHN0cmluZyk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMudmVoaWNsZURhdGEuZ2V0KGlkKVxuICB9XG5cbiAgZ2V0QWxsVmVoaWNsZXMoKTogYW55W10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudmVoaWNsZURhdGEudmFsdWVzKCkpXG4gIH1cblxuICByZW1vdmVWZWhpY2xlKGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnZlaGljbGVEYXRhLmRlbGV0ZShpZClcbiAgfVxuXG4gIHByaXZhdGUgY2xlYW51cE9sZFZlaGljbGVzKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICBjb25zdCBtYXhBZ2UgPSA1ICogNjAgKiAxMDAwIC8vIDUgbWludXRlc1xuXG4gICAgZm9yIChjb25zdCBbaWQsIGRhdGFdIG9mIHRoaXMudmVoaWNsZURhdGEuZW50cmllcygpKSB7XG4gICAgICBpZiAobm93IC0gZGF0YS5sYXN0VXBkYXRlID4gbWF4QWdlKSB7XG4gICAgICAgIHRoaXMudmVoaWNsZURhdGEuZGVsZXRlKGlkKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGDwn6e5IENsZWFuZWQgdXAgb2xkIHZlaGljbGVzLiBDdXJyZW50IGNvdW50OiAke3RoaXMudmVoaWNsZURhdGEuc2l6ZX1gKVxuICB9XG5cbiAgcHJpdmF0ZSBzdGFydENsZWFudXAoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xlYW51cEludGVydmFsKSByZXR1cm5cblxuICAgIHRoaXMuY2xlYW51cEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhbnVwT2xkVmVoaWNsZXMoKVxuICAgIH0sIDYwMDAwKSAvLyBDbGVhbnVwIGV2ZXJ5IG1pbnV0ZVxuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGVhbnVwSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwSW50ZXJ2YWwpXG4gICAgICB0aGlzLmNsZWFudXBJbnRlcnZhbCA9IG51bGxcbiAgICB9XG4gICAgdGhpcy52ZWhpY2xlRGF0YS5jbGVhcigpXG4gIH1cbn1cblxuLy8gSW5pdGlhbGl6ZSBtZW1vcnkgbGVhayBwcmV2ZW50aW9uXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZU1lbW9yeUxlYWtQcmV2ZW50aW9uID0gKCk6IHZvaWQgPT4ge1xuICBjb25zdCBkZXRlY3RvciA9IE1lbW9yeUxlYWtEZXRlY3Rvci5nZXRJbnN0YW5jZSgpXG4gIFxuICAvLyBTdGFydCBtZW1vcnkgbW9uaXRvcmluZ1xuICBkZXRlY3Rvci5zdGFydE1lbW9yeU1vbml0b3JpbmcoKVxuXG4gIC8vIENsZWFuIHVwIG9uIHBhZ2UgdW5sb2FkXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XG4gICAgICBkZXRlY3Rvci5jbGVhbnVwQWxsKClcbiAgICAgIFZlaGljbGVEYXRhTWFuYWdlci5nZXRJbnN0YW5jZSgpLmRlc3Ryb3koKVxuICAgIH0pXG5cbiAgICAvLyBDbGVhbiB1cCBvbiB2aXNpYmlsaXR5IGNoYW5nZSAodGFiIHN3aXRjaClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgKCkgPT4ge1xuICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAvLyBQZXJmb3JtIGNsZWFudXAgd2hlbiB0YWIgYmVjb21lcyBoaWRkZW5cbiAgICAgICAgZGV0ZWN0b3IuY2xlYW51cEFsbCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNvbnNvbGUubG9nKCfwn6egIE1lbW9yeSBsZWFrIHByZXZlbnRpb24gaW5pdGlhbGl6ZWQnKVxufVxuXG4vLyBFeHBvcnQgdXRpbGl0aWVzXG5leHBvcnQgZGVmYXVsdCB7XG4gIE1lbW9yeUxlYWtEZXRlY3RvcixcbiAgVmVoaWNsZURhdGFNYW5hZ2VyLFxuICB1c2VNZW1vcnlMZWFrUHJldmVudGlvbixcbiAgaW5pdGlhbGl6ZU1lbW9yeUxlYWtQcmV2ZW50aW9uXG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJNZW1vcnlMZWFrRGV0ZWN0b3IiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwidHJhY2tJbnRlcnZhbCIsImludGVydmFsIiwiaW50ZXJ2YWxzIiwiYWRkIiwidHJhY2tUaW1lb3V0IiwidGltZW91dCIsInRpbWVvdXRzIiwidHJhY2tFdmVudExpc3RlbmVyIiwidGFyZ2V0IiwiZXZlbnQiLCJsaXN0ZW5lciIsImV2ZW50TGlzdGVuZXJzIiwiaGFzIiwic2V0IiwiTWFwIiwiZ2V0IiwidHJhY2tPYnNlcnZlciIsIm9ic2VydmVyIiwib2JzZXJ2ZXJzIiwidHJhY2tBYm9ydENvbnRyb2xsZXIiLCJjb250cm9sbGVyIiwiYWJvcnRDb250cm9sbGVycyIsImNsZWFySW50ZXJ2YWwiLCJkZWxldGUiLCJjbGVhclRpbWVvdXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGlzdGVuZXJzIiwic2l6ZSIsImRpc2Nvbm5lY3RPYnNlcnZlciIsImRpc2Nvbm5lY3QiLCJhYm9ydENvbnRyb2xsZXIiLCJhYm9ydCIsImNsZWFudXBBbGwiLCJjb25zb2xlIiwibG9nIiwiZm9yRWFjaCIsImNsZWFyIiwibWVtb3J5TW9uaXRvckludGVydmFsIiwic3RhcnRNZW1vcnlNb25pdG9yaW5nIiwic2V0SW50ZXJ2YWwiLCJ3aW5kb3ciLCJwZXJmb3JtYW5jZSIsIm1lbW9yeSIsIm1lbW9yeVVzYWdlIiwidXNlZCIsIk1hdGgiLCJyb3VuZCIsInVzZWRKU0hlYXBTaXplIiwidG90YWwiLCJ0b3RhbEpTSGVhcFNpemUiLCJsaW1pdCIsImpzSGVhcFNpemVMaW1pdCIsIndhcm4iLCJnZXRNZW1vcnlTdGF0cyIsInRyYWNrZWRSZXNvdXJjZXMiLCJTZXQiLCJ1c2VNZW1vcnlMZWFrUHJldmVudGlvbiIsImRldGVjdG9yIiwiY2xlYW51cEZ1bmN0aW9ucyIsImFkZENsZWFudXAiLCJjbGVhbnVwIiwiY3VycmVudCIsInB1c2giLCJzYWZlU2V0SW50ZXJ2YWwiLCJjYWxsYmFjayIsImRlbGF5Iiwic2FmZVNldFRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwic2FmZUFkZEV2ZW50TGlzdGVuZXIiLCJvcHRpb25zIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNhZmVDcmVhdGVPYnNlcnZlciIsInNhZmVDcmVhdGVBYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJlcnJvciIsIlZlaGljbGVEYXRhTWFuYWdlciIsImFkZFZlaGljbGUiLCJpZCIsImRhdGEiLCJ2ZWhpY2xlRGF0YSIsImxhc3RVcGRhdGUiLCJEYXRlIiwibm93IiwibWF4VmVoaWNsZXMiLCJjbGVhbnVwT2xkVmVoaWNsZXMiLCJnZXRWZWhpY2xlIiwiZ2V0QWxsVmVoaWNsZXMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJyZW1vdmVWZWhpY2xlIiwibWF4QWdlIiwiZW50cmllcyIsInN0YXJ0Q2xlYW51cCIsImNsZWFudXBJbnRlcnZhbCIsImRlc3Ryb3kiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxpemVNZW1vcnlMZWFrUHJldmVudGlvbiIsImRvY3VtZW50IiwiaGlkZGVuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/memoryLeakFixes.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/websocket.ts":
/*!***********************************!*\
  !*** ./src/services/websocket.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWebSocket: () => (/* binding */ useWebSocket),\n/* harmony export */   websocketService: () => (/* binding */ websocketService)\n/* harmony export */ });\n/* harmony import */ var _lib_memoryLeakFixes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/memoryLeakFixes */ \"(app-pages-browser)/./src/lib/memoryLeakFixes.ts\");\n/* harmony import */ var _store_useStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/store/useStore */ \"(app-pages-browser)/./src/store/useStore.ts\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n\n\n\nclass WebSocketService {\n    // Auto-detect WebSocket URL based on current environment\n    getWebSocketUrl() {\n        // Check if we're in development or production\n        const isDev =  true || 0;\n        if (isDev) {\n            // In development, always use localhost:8002\n            return 'http://localhost:8002';\n        } else {\n            // In production, use the same host but port 8002\n            const protocol = window.location.protocol === 'https:' ? 'https:' : 'http:';\n            const hostname = window.location.hostname;\n            return \"\".concat(protocol, \"//\").concat(hostname, \":8002\");\n        }\n    }\n    connect(url) {\n        try {\n            // Auto-detect WebSocket URL based on current environment\n            const defaultUrl = this.getWebSocketUrl();\n            const targetUrl = url || defaultUrl;\n            this.connectionUrl = targetUrl;\n            this.isManualDisconnect = false;\n            console.log('🔌 Attempting WebSocket connection to:', targetUrl);\n            console.log('🌐 Current frontend URL:', window.location.href);\n            console.log('🔍 Auto-detected WebSocket URL:', defaultUrl);\n            // Clear any existing reconnect timeout\n            if (this.reconnectTimeout) {\n                clearTimeout(this.reconnectTimeout);\n                this.reconnectTimeout = null;\n            }\n            this.connectionStatus = 'connecting';\n            // Disconnect existing connection if any\n            if (this.socket) {\n                console.log('🔄 Disconnecting existing socket...');\n                this.socket.disconnect();\n                this.socket = null;\n            }\n            this.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(targetUrl, {\n                transports: [\n                    'polling',\n                    'websocket'\n                ],\n                timeout: 20000,\n                forceNew: true,\n                autoConnect: true,\n                reconnection: true,\n                reconnectionAttempts: 5,\n                reconnectionDelay: 3000,\n                reconnectionDelayMax: 15000,\n                randomizationFactor: 0.3,\n                upgrade: true,\n                rememberUpgrade: false,\n                // Additional options for better compatibility\n                withCredentials: false,\n                extraHeaders: {\n                    'Access-Control-Allow-Origin': '*'\n                }\n            });\n            this.setupEventListeners();\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setConnectionStatus('connecting');\n            console.log('🔄 WebSocket status set to connecting');\n            // Connection will happen automatically due to autoConnect: true\n            console.log('🚀 WebSocket connection will establish automatically');\n        } catch (error) {\n            console.error('❌ WebSocket connection initialization error:', error);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setConnectionStatus('disconnected');\n        }\n    }\n    setupEventListeners() {\n        if (!this.socket) return;\n        // Connection events\n        this.socket.on('connect', ()=>{\n            var _this_socket, _this_socket1;\n            console.log('✅ WebSocket connected successfully!');\n            console.log('✅ Socket ID:', (_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.id);\n            console.log('✅ Transport:', (_this_socket1 = this.socket) === null || _this_socket1 === void 0 ? void 0 : _this_socket1.io.engine.transport.name);\n            this.connectionStatus = 'connected';\n            this.reconnectAttempts = 0 // Reset reconnect attempts on successful connection\n            ;\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setConnectionStatus('connected');\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n            // Start heartbeat to maintain connection\n            this.startHeartbeat();\n        });\n        this.socket.on('disconnect', (reason)=>{\n            console.log('❌ WebSocket disconnected:', reason);\n            this.connectionStatus = 'disconnected';\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setConnectionStatus('disconnected');\n            // Clear heartbeat\n            if (this.heartbeatInterval) {\n                clearInterval(this.heartbeatInterval);\n                this.heartbeatInterval = null;\n            }\n            // Only try to reconnect for specific reasons, not all disconnects\n            if (reason === 'io server disconnect' || reason === 'transport close' || reason === 'transport error') {\n                console.log('🔄 Server initiated disconnect, scheduling reconnect');\n                this.scheduleReconnect();\n            } else {\n                console.log('🔄 Client initiated disconnect, no reconnect needed');\n            }\n        });\n        this.socket.on('connect_error', (error)=>{\n            var _this_socket, _this_socket1, _this_socket_io_engine_transport, _this_socket_io_engine, _this_socket_io, _this_socket2;\n            console.error('❌ WebSocket connection error:', error);\n            console.error('❌ Error details:', {\n                message: error.message,\n                type: error.constructor.name,\n                stack: error.stack\n            });\n            console.error('❌ Socket state:', {\n                connected: (_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected,\n                disconnected: (_this_socket1 = this.socket) === null || _this_socket1 === void 0 ? void 0 : _this_socket1.disconnected,\n                transport: ((_this_socket2 = this.socket) === null || _this_socket2 === void 0 ? void 0 : (_this_socket_io = _this_socket2.io) === null || _this_socket_io === void 0 ? void 0 : (_this_socket_io_engine = _this_socket_io.engine) === null || _this_socket_io_engine === void 0 ? void 0 : (_this_socket_io_engine_transport = _this_socket_io_engine.transport) === null || _this_socket_io_engine_transport === void 0 ? void 0 : _this_socket_io_engine_transport.name) || 'unknown'\n            });\n            this.connectionStatus = 'error';\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setConnectionStatus('error');\n            // Schedule reconnect on connection error\n            this.scheduleReconnect();\n        });\n        // Data events\n        this.socket.on('vehicles_update', (vehicles)=>{\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setVehicles(vehicles);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('vehicle_update', (param)=>{\n            let { id, updates } = param;\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateVehicle(id, updates);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('routes_update', (routes)=>{\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setRoutes(routes);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('route_update', (param)=>{\n            let { id, updates } = param;\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateRoute(id, updates);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('kpis_update', (kpis)=>{\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setKPIs(kpis);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('trips_update', (trips)=>{\n            console.log('🚗 Received trips update:', (trips === null || trips === void 0 ? void 0 : trips.length) || 0, 'trips');\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setTrips(trips);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('kpi_update', (param)=>{\n            let { id, updates } = param;\n            if (typeof updates.value === 'string') {\n                updates.value = parseFloat(updates.value);\n            }\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateKPI(id, updates);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('alert', (alert)=>{\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().addAlert(alert);\n            // Show browser notification if enabled\n            if (_store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().notifications && 'Notification' in window) {\n                if (Notification.permission === 'granted') {\n                    new Notification(alert.title, {\n                        body: alert.message,\n                        icon: '/favicon.svg',\n                        tag: alert.type\n                    });\n                }\n            }\n        });\n        this.socket.on('scenarios_update', (scenarios)=>{\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setScenarios(scenarios);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        // Ghana-specific events\n        this.socket.on('ghana_weather_update', (weather)=>{\n            // Handle weather updates that might affect transport\n            if (weather.is_rainy && weather.rain_intensity === 'high') {\n                _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().addAlert({\n                    type: 'warning',\n                    title: 'Heavy Rain Alert',\n                    message: 'Heavy rainfall detected in Accra. Expect traffic delays and potential flooding.',\n                    read: false\n                });\n            }\n        });\n        this.socket.on('ghana_holiday_alert', (holiday)=>{\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().addAlert({\n                type: 'info',\n                title: 'Ghana Public Holiday',\n                message: \"Today is \".concat(holiday.name, \". Expect reduced transport services.\"),\n                read: false\n            });\n        });\n        this.socket.on('crisis_scenario', (scenario)=>{\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().addAlert({\n                type: 'error',\n                title: 'Crisis Alert',\n                message: \"\".concat(scenario.name, \": \").concat(scenario.description),\n                read: false\n            });\n        });\n        // ML/AI events (Phase 3)\n        this.socket.on('ml_prediction', (prediction)=>{\n            const mlPrediction = {\n                ...prediction,\n                timestamp: new Date(prediction.timestamp)\n            };\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().addMLPrediction(mlPrediction);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('anomaly_detected', (anomaly)=>{\n            const anomalyEvent = {\n                ...anomaly,\n                detected_at: new Date(anomaly.detected_at)\n            };\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().addAnomaly(anomalyEvent);\n            // Create alert for high severity anomalies\n            if (anomaly.severity === 'high' || anomaly.severity === 'critical') {\n                _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().addAlert({\n                    type: anomaly.severity === 'critical' ? 'error' : 'warning',\n                    title: \"Anomaly Detected: \".concat(anomaly.title),\n                    message: anomaly.description,\n                    read: false\n                });\n            }\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('ai_insights', (insights)=>{\n            // Add individual insights\n            if (insights.insights) {\n                Object.values(insights.insights).flat().forEach((insight)=>{\n                    const aiInsight = {\n                        ...insight,\n                        timestamp: new Date(insight.timestamp || Date.now())\n                    };\n                    _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().addAIInsight(aiInsight);\n                });\n            }\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('scenario_analysis', (analysis)=>{\n            const scenarioAnalysis = {\n                ...analysis,\n                timestamp: new Date()\n            };\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().addScenarioAnalysis(scenarioAnalysis);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('cultural_insights', (insights)=>{\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setCulturalInsights(insights);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n        this.socket.on('economic_analysis', (analysis)=>{\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setEconomicAnalysis(analysis);\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().updateLastUpdate();\n        });\n    }\n    // Removed handleReconnect - Socket.IO handles reconnection automatically\n    // Emit events to server\n    emit(event, data) {\n        var _this_socket;\n        if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {\n            this.socket.emit(event, data);\n        } else {\n            console.warn('WebSocket not connected, cannot emit event:', event);\n        }\n    }\n    // Scenario control\n    activateScenario(scenarioId, parameters) {\n        this.emit('activate_scenario', {\n            scenarioId,\n            parameters\n        });\n    }\n    deactivateScenario(scenarioId) {\n        this.emit('deactivate_scenario', {\n            scenarioId\n        });\n    }\n    // Request data updates\n    requestVehicleUpdate() {\n        this.emit('request_vehicles');\n    }\n    requestRouteUpdate() {\n        this.emit('request_routes');\n    }\n    requestKPIUpdate() {\n        this.emit('request_kpis');\n    }\n    // Send user preferences\n    updateUserPreferences(preferences) {\n        this.emit('user_preferences', preferences);\n    }\n    disconnect() {\n        this.isManualDisconnect = true;\n        this.connectionStatus = 'disconnected';\n        console.log('🧹 WebSocket: Starting comprehensive cleanup...');\n        // Clear all timers with memory leak prevention\n        if (this.reconnectTimeout) {\n            this.memoryDetector.clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        if (this.heartbeatInterval) {\n            this.memoryDetector.clearInterval(this.heartbeatInterval);\n            this.heartbeatInterval = null;\n        }\n        if (this.socket) {\n            console.log('🔌 Disconnecting WebSocket...');\n            // Remove all event listeners to prevent memory leaks\n            this.socket.removeAllListeners();\n            // Disconnect the socket\n            this.socket.disconnect();\n            this.socket = null;\n            _store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore.getState().setConnectionStatus('disconnected');\n            console.log('✅ WebSocket cleanup completed');\n        }\n    }\n    scheduleReconnect() {\n        if (this.isManualDisconnect || this.reconnectAttempts >= this.maxReconnectAttempts) {\n            console.log('🚫 Not scheduling reconnect - manual disconnect or max attempts reached');\n            return;\n        }\n        this.reconnectAttempts++;\n        const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), 30000) // Max 30 seconds\n        ;\n        console.log(\"\\uD83D\\uDD04 Scheduling reconnect attempt \".concat(this.reconnectAttempts, \"/\").concat(this.maxReconnectAttempts, \" in \").concat(delay, \"ms\"));\n        this.reconnectTimeout = setTimeout(()=>{\n            if (!this.isManualDisconnect) {\n                console.log(\"\\uD83D\\uDD04 Reconnect attempt \".concat(this.reconnectAttempts, \"/\").concat(this.maxReconnectAttempts));\n                this.connect(this.connectionUrl);\n            }\n        }, delay);\n    }\n    startHeartbeat() {\n        if (this.heartbeatInterval) {\n            clearInterval(this.heartbeatInterval);\n        }\n        this.heartbeatInterval = setInterval(()=>{\n            if (this.socket && this.socket.connected) {\n                this.socket.emit('ping');\n            }\n        }, 30000) // Ping every 30 seconds\n        ;\n    }\n    isConnected() {\n        var _this_socket;\n        return ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) || false;\n    }\n    getConnectionStatus() {\n        if (!this.socket) return 'disconnected';\n        if (this.socket.connected) return 'connected';\n        if (this.socket.connecting) return 'connecting';\n        return 'disconnected';\n    }\n    getSocket() {\n        return this.socket;\n    }\n    constructor(){\n        this.socket = null;\n        this.connectionStatus = 'disconnected';\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 10 // Increased for better reliability\n        ;\n        this.reconnectDelay = 1000 // Start with 1 second\n        ;\n        this.reconnectTimeout = null;\n        this.heartbeatInterval = null;\n        this.connectionUrl = '';\n        this.memoryDetector = _lib_memoryLeakFixes__WEBPACK_IMPORTED_MODULE_0__.MemoryLeakDetector.getInstance();\n        this.isManualDisconnect = false;\n    }\n}\n// Singleton instance\nconst websocketService = new WebSocketService();\n// Hook for easy access in components\nconst useWebSocket = ()=>{\n    const connected = (0,_store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore)({\n        \"useWebSocket.useStore[connected]\": (state)=>state.connected\n    }[\"useWebSocket.useStore[connected]\"]);\n    const connectionStatus = (0,_store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore)({\n        \"useWebSocket.useStore[connectionStatus]\": (state)=>state.connectionStatus\n    }[\"useWebSocket.useStore[connectionStatus]\"]);\n    const lastUpdate = (0,_store_useStore__WEBPACK_IMPORTED_MODULE_1__.useStore)({\n        \"useWebSocket.useStore[lastUpdate]\": (state)=>state.lastUpdate\n    }[\"useWebSocket.useStore[lastUpdate]\"]);\n    return {\n        connected,\n        connectionStatus,\n        lastUpdate,\n        connect: websocketService.connect.bind(websocketService),\n        disconnect: websocketService.disconnect.bind(websocketService),\n        emit: websocketService.emit.bind(websocketService),\n        activateScenario: websocketService.activateScenario.bind(websocketService),\n        deactivateScenario: websocketService.deactivateScenario.bind(websocketService),\n        requestVehicleUpdate: websocketService.requestVehicleUpdate.bind(websocketService),\n        requestRouteUpdate: websocketService.requestRouteUpdate.bind(websocketService),\n        requestKPIUpdate: websocketService.requestKPIUpdate.bind(websocketService)\n    };\n} // Export the service without auto-connecting\n // Components will connect manually when needed\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy93ZWJzb2NrZXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEQ7QUFDZjtBQUNWO0FBa0RqQyxNQUFNRztJQVlKLHlEQUF5RDtJQUNqREMsa0JBQTBCO1FBQ2hDLDhDQUE4QztRQUM5QyxNQUFNQyxRQUFRQyxLQUFzQyxJQUFJQyxDQUF3QztRQUVoRyxJQUFJRixPQUFPO1lBQ1QsNENBQTRDO1lBQzVDLE9BQU87UUFDVCxPQUFPO1lBQ0wsaURBQWlEO1lBQ2pELE1BQU1LLFdBQVdILE9BQU9DLFFBQVEsQ0FBQ0UsUUFBUSxLQUFLLFdBQVcsV0FBVztZQUNwRSxNQUFNRCxXQUFXRixPQUFPQyxRQUFRLENBQUNDLFFBQVE7WUFDekMsT0FBTyxHQUFnQkEsT0FBYkMsVUFBUyxNQUFhLE9BQVRELFVBQVM7UUFDbEM7SUFDRjtJQUVBRSxRQUFRQyxHQUFZLEVBQUU7UUFDcEIsSUFBSTtZQUNGLHlEQUF5RDtZQUN6RCxNQUFNQyxhQUFhLElBQUksQ0FBQ1QsZUFBZTtZQUN2QyxNQUFNVSxZQUFZRixPQUFPQztZQUN6QixJQUFJLENBQUNFLGFBQWEsR0FBR0Q7WUFDckIsSUFBSSxDQUFDRSxrQkFBa0IsR0FBRztZQUUxQkMsUUFBUUMsR0FBRyxDQUFDLDBDQUEwQ0o7WUFDdERHLFFBQVFDLEdBQUcsQ0FBQyw0QkFBNEJYLE9BQU9DLFFBQVEsQ0FBQ1csSUFBSTtZQUM1REYsUUFBUUMsR0FBRyxDQUFDLG1DQUFtQ0w7WUFFL0MsdUNBQXVDO1lBQ3ZDLElBQUksSUFBSSxDQUFDTyxnQkFBZ0IsRUFBRTtnQkFDekJDLGFBQWEsSUFBSSxDQUFDRCxnQkFBZ0I7Z0JBQ2xDLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUc7WUFDMUI7WUFFQSxJQUFJLENBQUNFLGdCQUFnQixHQUFHO1lBRXhCLHdDQUF3QztZQUN4QyxJQUFJLElBQUksQ0FBQ0MsTUFBTSxFQUFFO2dCQUNmTixRQUFRQyxHQUFHLENBQUM7Z0JBQ1osSUFB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dEksT0FBTyxDQUFDMEksSUFBSSxDQUFDSjtRQUN2Q3pILFlBQVl5SCxpQkFBaUJ6SCxVQUFVLENBQUM2SCxJQUFJLENBQUNKO1FBQzdDNUIsTUFBTTRCLGlCQUFpQjVCLElBQUksQ0FBQ2dDLElBQUksQ0FBQ0o7UUFDakN4QixrQkFBa0J3QixpQkFBaUJ4QixnQkFBZ0IsQ0FBQzRCLElBQUksQ0FBQ0o7UUFDekRyQixvQkFBb0JxQixpQkFBaUJyQixrQkFBa0IsQ0FBQ3lCLElBQUksQ0FBQ0o7UUFDN0RwQixzQkFBc0JvQixpQkFBaUJwQixvQkFBb0IsQ0FBQ3dCLElBQUksQ0FBQ0o7UUFDakVuQixvQkFBb0JtQixpQkFBaUJuQixrQkFBa0IsQ0FBQ3VCLElBQUksQ0FBQ0o7UUFDN0RsQixrQkFBa0JrQixpQkFBaUJsQixnQkFBZ0IsQ0FBQ3NCLElBQUksQ0FBQ0o7SUFDM0Q7QUFDRixFQUVBLDZDQUE2QztDQUM3QywrQ0FBK0M7Q0FIOUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc2FtXFxEZXNrdG9wXFxhdXJhXFxzcmNcXHNlcnZpY2VzXFx3ZWJzb2NrZXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVtb3J5TGVha0RldGVjdG9yIH0gZnJvbSAnQC9saWIvbWVtb3J5TGVha0ZpeGVzJ1xuaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAL3N0b3JlL3VzZVN0b3JlJ1xuaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnXG5cbmludGVyZmFjZSBWZWhpY2xlIHtcbiAgaWQ6IHN0cmluZ1xuICByb3V0ZTogc3RyaW5nXG4gIGxhdDogbnVtYmVyXG4gIGxuZzogbnVtYmVyXG4gIHNwZWVkOiBudW1iZXJcbiAgcGFzc2VuZ2VyczogbnVtYmVyXG4gIGNhcGFjaXR5OiBudW1iZXJcbiAgc3RhdHVzOiBzdHJpbmdcbiAgbGFzdFVwZGF0ZTogc3RyaW5nXG59XG5cbmludGVyZmFjZSBSb3V0ZSB7XG4gIGlkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXR1czogc3RyaW5nXG59XG5cbmludGVyZmFjZSBLUEkge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICB2YWx1ZTogbnVtYmVyXG4gIGNoYW5nZTogbnVtYmVyXG4gIHRyZW5kOiAndXAnIHwgJ2Rvd24nIHwgJ25ldXRyYWwnXG59XG5cbmludGVyZmFjZSBBbGVydCB7XG4gIHR5cGU6ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAnc3VjY2VzcydcbiAgdGl0bGU6IHN0cmluZ1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgcmVhZDogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgU2NlbmFyaW8ge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG59XG5cbmludGVyZmFjZSBXZWF0aGVyIHtcbiAgaXNfcmFpbnk6IGJvb2xlYW5cbiAgcmFpbl9pbnRlbnNpdHk6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgSG9saWRheSB7XG4gIG5hbWU6IHN0cmluZ1xufVxuXG5jbGFzcyBXZWJTb2NrZXRTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzb2NrZXQ6IGFueSA9IG51bGxcbiAgcHJpdmF0ZSBjb25uZWN0aW9uU3RhdHVzOiAnZGlzY29ubmVjdGVkJyB8ICdjb25uZWN0aW5nJyB8ICdjb25uZWN0ZWQnIHwgJ2Vycm9yJyA9ICdkaXNjb25uZWN0ZWQnXG4gIHByaXZhdGUgcmVjb25uZWN0QXR0ZW1wdHMgPSAwXG4gIHByaXZhdGUgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSAxMCAvLyBJbmNyZWFzZWQgZm9yIGJldHRlciByZWxpYWJpbGl0eVxuICBwcml2YXRlIHJlY29ubmVjdERlbGF5ID0gMTAwMCAvLyBTdGFydCB3aXRoIDEgc2Vjb25kXG4gIHByaXZhdGUgcmVjb25uZWN0VGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIGhlYXJ0YmVhdEludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgY29ubmVjdGlvblVybDogc3RyaW5nID0gJydcbiAgcHJpdmF0ZSBtZW1vcnlEZXRlY3RvciA9IE1lbW9yeUxlYWtEZXRlY3Rvci5nZXRJbnN0YW5jZSgpXG4gIHByaXZhdGUgaXNNYW51YWxEaXNjb25uZWN0ID0gZmFsc2VcblxuICAvLyBBdXRvLWRldGVjdCBXZWJTb2NrZXQgVVJMIGJhc2VkIG9uIGN1cnJlbnQgZW52aXJvbm1lbnRcbiAgcHJpdmF0ZSBnZXRXZWJTb2NrZXRVcmwoKTogc3RyaW5nIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbiBkZXZlbG9wbWVudCBvciBwcm9kdWN0aW9uXG4gICAgY29uc3QgaXNEZXYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyB8fCB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnXG5cbiAgICBpZiAoaXNEZXYpIHtcbiAgICAgIC8vIEluIGRldmVsb3BtZW50LCBhbHdheXMgdXNlIGxvY2FsaG9zdDo4MDAyXG4gICAgICByZXR1cm4gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMidcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgdXNlIHRoZSBzYW1lIGhvc3QgYnV0IHBvcnQgODAwMlxuICAgICAgY29uc3QgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gJ2h0dHBzOicgOiAnaHR0cDonXG4gICAgICBjb25zdCBob3N0bmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZVxuICAgICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX06ODAwMmBcbiAgICB9XG4gIH1cblxuICBjb25uZWN0KHVybD86IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICAvLyBBdXRvLWRldGVjdCBXZWJTb2NrZXQgVVJMIGJhc2VkIG9uIGN1cnJlbnQgZW52aXJvbm1lbnRcbiAgICAgIGNvbnN0IGRlZmF1bHRVcmwgPSB0aGlzLmdldFdlYlNvY2tldFVybCgpXG4gICAgICBjb25zdCB0YXJnZXRVcmwgPSB1cmwgfHwgZGVmYXVsdFVybFxuICAgICAgdGhpcy5jb25uZWN0aW9uVXJsID0gdGFyZ2V0VXJsXG4gICAgICB0aGlzLmlzTWFudWFsRGlzY29ubmVjdCA9IGZhbHNlXG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SMIEF0dGVtcHRpbmcgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG86JywgdGFyZ2V0VXJsKVxuICAgICAgY29uc29sZS5sb2coJ/CfjJAgQ3VycmVudCBmcm9udGVuZCBVUkw6Jywgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBBdXRvLWRldGVjdGVkIFdlYlNvY2tldCBVUkw6JywgZGVmYXVsdFVybClcblxuICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHJlY29ubmVjdCB0aW1lb3V0XG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpXG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGxcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzID0gJ2Nvbm5lY3RpbmcnXG5cbiAgICAgIC8vIERpc2Nvbm5lY3QgZXhpc3RpbmcgY29ubmVjdGlvbiBpZiBhbnlcbiAgICAgIGlmICh0aGlzLnNvY2tldCkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBEaXNjb25uZWN0aW5nIGV4aXN0aW5nIHNvY2tldC4uLicpXG4gICAgICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKVxuICAgICAgICB0aGlzLnNvY2tldCA9IG51bGxcbiAgICAgIH1cblxuICAgICAgdGhpcy5zb2NrZXQgPSBpbyh0YXJnZXRVcmwsIHtcbiAgICAgICAgdHJhbnNwb3J0czogWydwb2xsaW5nJywgJ3dlYnNvY2tldCddLCAvLyBUcnkgcG9sbGluZyBmaXJzdCwgdGhlbiB1cGdyYWRlIHRvIHdlYnNvY2tldFxuICAgICAgICB0aW1lb3V0OiAyMDAwMCxcbiAgICAgICAgZm9yY2VOZXc6IHRydWUsXG4gICAgICAgIGF1dG9Db25uZWN0OiB0cnVlLFxuICAgICAgICByZWNvbm5lY3Rpb246IHRydWUsXG4gICAgICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiA1LFxuICAgICAgICByZWNvbm5lY3Rpb25EZWxheTogMzAwMCxcbiAgICAgICAgcmVjb25uZWN0aW9uRGVsYXlNYXg6IDE1MDAwLFxuICAgICAgICByYW5kb21pemF0aW9uRmFjdG9yOiAwLjMsXG4gICAgICAgIHVwZ3JhZGU6IHRydWUsXG4gICAgICAgIHJlbWVtYmVyVXBncmFkZTogZmFsc2UsXG4gICAgICAgIC8vIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgYmV0dGVyIGNvbXBhdGliaWxpdHlcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSwgLy8gRGlzYWJsZSBjcmVkZW50aWFscyBmb3IgQ09SU1xuICAgICAgICBleHRyYUhlYWRlcnM6IHtcbiAgICAgICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpXG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnNldENvbm5lY3Rpb25TdGF0dXMoJ2Nvbm5lY3RpbmcnKVxuICAgICAgY29uc29sZS5sb2coJ/CflIQgV2ViU29ja2V0IHN0YXR1cyBzZXQgdG8gY29ubmVjdGluZycpXG5cbiAgICAgIC8vIENvbm5lY3Rpb24gd2lsbCBoYXBwZW4gYXV0b21hdGljYWxseSBkdWUgdG8gYXV0b0Nvbm5lY3Q6IHRydWVcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFdlYlNvY2tldCBjb25uZWN0aW9uIHdpbGwgZXN0YWJsaXNoIGF1dG9tYXRpY2FsbHknKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgV2ViU29ja2V0IGNvbm5lY3Rpb24gaW5pdGlhbGl6YXRpb24gZXJyb3I6JywgZXJyb3IpXG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnNldENvbm5lY3Rpb25TdGF0dXMoJ2Rpc2Nvbm5lY3RlZCcpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICghdGhpcy5zb2NrZXQpIHJldHVyblxuXG4gICAgLy8gQ29ubmVjdGlvbiBldmVudHNcbiAgICB0aGlzLnNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgV2ViU29ja2V0IGNvbm5lY3RlZCBzdWNjZXNzZnVsbHkhJylcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgU29ja2V0IElEOicsIHRoaXMuc29ja2V0Py5pZClcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVHJhbnNwb3J0OicsIHRoaXMuc29ja2V0Py5pby5lbmdpbmUudHJhbnNwb3J0Lm5hbWUpXG4gICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXMgPSAnY29ubmVjdGVkJ1xuICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDAgLy8gUmVzZXQgcmVjb25uZWN0IGF0dGVtcHRzIG9uIHN1Y2Nlc3NmdWwgY29ubmVjdGlvblxuICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS5zZXRDb25uZWN0aW9uU3RhdHVzKCdjb25uZWN0ZWQnKVxuICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS51cGRhdGVMYXN0VXBkYXRlKClcblxuICAgICAgLy8gU3RhcnQgaGVhcnRiZWF0IHRvIG1haW50YWluIGNvbm5lY3Rpb25cbiAgICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKVxuICAgIH0pXG5cbiAgICB0aGlzLnNvY2tldC5vbignZGlzY29ubmVjdCcsIChyZWFzb246IHN0cmluZykgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBXZWJTb2NrZXQgZGlzY29ubmVjdGVkOicsIHJlYXNvbilcbiAgICAgIHRoaXMuY29ubmVjdGlvblN0YXR1cyA9ICdkaXNjb25uZWN0ZWQnXG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnNldENvbm5lY3Rpb25TdGF0dXMoJ2Rpc2Nvbm5lY3RlZCcpXG5cbiAgICAgIC8vIENsZWFyIGhlYXJ0YmVhdFxuICAgICAgaWYgKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdEludGVydmFsKVxuICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsID0gbnVsbFxuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgZm9yIHNwZWNpZmljIHJlYXNvbnMsIG5vdCBhbGwgZGlzY29ubmVjdHNcbiAgICAgIGlmIChyZWFzb24gPT09ICdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcgfHwgcmVhc29uID09PSAndHJhbnNwb3J0IGNsb3NlJyB8fCByZWFzb24gPT09ICd0cmFuc3BvcnQgZXJyb3InKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFNlcnZlciBpbml0aWF0ZWQgZGlzY29ubmVjdCwgc2NoZWR1bGluZyByZWNvbm5lY3QnKVxuICAgICAgICB0aGlzLnNjaGVkdWxlUmVjb25uZWN0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIENsaWVudCBpbml0aWF0ZWQgZGlzY29ubmVjdCwgbm8gcmVjb25uZWN0IG5lZWRlZCcpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuc29ja2V0Lm9uKCdjb25uZWN0X2Vycm9yJywgKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFdlYlNvY2tldCBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKVxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRldGFpbHM6Jywge1xuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICB0eXBlOiBlcnJvci5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgIH0pXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgU29ja2V0IHN0YXRlOicsIHtcbiAgICAgICAgY29ubmVjdGVkOiB0aGlzLnNvY2tldD8uY29ubmVjdGVkLFxuICAgICAgICBkaXNjb25uZWN0ZWQ6IHRoaXMuc29ja2V0Py5kaXNjb25uZWN0ZWQsXG4gICAgICAgIHRyYW5zcG9ydDogdGhpcy5zb2NrZXQ/LmlvPy5lbmdpbmU/LnRyYW5zcG9ydD8ubmFtZSB8fCAndW5rbm93bidcbiAgICAgIH0pXG4gICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXMgPSAnZXJyb3InXG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnNldENvbm5lY3Rpb25TdGF0dXMoJ2Vycm9yJylcblxuICAgICAgLy8gU2NoZWR1bGUgcmVjb25uZWN0IG9uIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgIHRoaXMuc2NoZWR1bGVSZWNvbm5lY3QoKVxuICAgIH0pXG5cbiAgICAvLyBEYXRhIGV2ZW50c1xuICAgIHRoaXMuc29ja2V0Lm9uKCd2ZWhpY2xlc191cGRhdGUnLCAodmVoaWNsZXM6IGFueVtdKSA9PiB7XG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnNldFZlaGljbGVzKHZlaGljbGVzIGFzIGFueSlcbiAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkudXBkYXRlTGFzdFVwZGF0ZSgpXG4gICAgfSlcblxuICAgIHRoaXMuc29ja2V0Lm9uKCd2ZWhpY2xlX3VwZGF0ZScsICh7IGlkLCB1cGRhdGVzIH06IHsgaWQ6IHN0cmluZywgdXBkYXRlczogYW55IH0pID0+IHtcbiAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkudXBkYXRlVmVoaWNsZShpZCwgdXBkYXRlcyBhcyBhbnkpXG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnVwZGF0ZUxhc3RVcGRhdGUoKVxuICAgIH0pXG5cbiAgICB0aGlzLnNvY2tldC5vbigncm91dGVzX3VwZGF0ZScsIChyb3V0ZXM6IGFueVtdKSA9PiB7XG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnNldFJvdXRlcyhyb3V0ZXMgYXMgYW55KVxuICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS51cGRhdGVMYXN0VXBkYXRlKClcbiAgICB9KVxuXG4gICAgdGhpcy5zb2NrZXQub24oJ3JvdXRlX3VwZGF0ZScsICh7IGlkLCB1cGRhdGVzIH06IHsgaWQ6IHN0cmluZywgdXBkYXRlczogYW55IH0pID0+IHtcbiAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkudXBkYXRlUm91dGUoaWQsIHVwZGF0ZXMgYXMgYW55KVxuICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS51cGRhdGVMYXN0VXBkYXRlKClcbiAgICB9KVxuXG4gICAgdGhpcy5zb2NrZXQub24oJ2twaXNfdXBkYXRlJywgKGtwaXM6IGFueVtdKSA9PiB7XG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnNldEtQSXMoa3BpcyBhcyBhbnkpXG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnVwZGF0ZUxhc3RVcGRhdGUoKVxuICAgIH0pXG5cbiAgICB0aGlzLnNvY2tldC5vbigndHJpcHNfdXBkYXRlJywgKHRyaXBzOiBhbnlbXSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ/CfmpcgUmVjZWl2ZWQgdHJpcHMgdXBkYXRlOicsIHRyaXBzPy5sZW5ndGggfHwgMCwgJ3RyaXBzJylcbiAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkuc2V0VHJpcHModHJpcHMgYXMgYW55KVxuICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS51cGRhdGVMYXN0VXBkYXRlKClcbiAgICB9KVxuXG4gICAgdGhpcy5zb2NrZXQub24oJ2twaV91cGRhdGUnLCAoeyBpZCwgdXBkYXRlcyB9OiB7IGlkOiBzdHJpbmcsIHVwZGF0ZXM6IGFueSB9KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHVwZGF0ZXMudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHVwZGF0ZXMudmFsdWUgPSBwYXJzZUZsb2F0KHVwZGF0ZXMudmFsdWUpXG4gICAgICB9XG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnVwZGF0ZUtQSShpZCwgdXBkYXRlcyBhcyBhbnkpXG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnVwZGF0ZUxhc3RVcGRhdGUoKVxuICAgIH0pXG5cbiAgICB0aGlzLnNvY2tldC5vbignYWxlcnQnLCAoYWxlcnQ6IGFueSkgPT4ge1xuICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS5hZGRBbGVydChhbGVydCBhcyBhbnkpXG4gICAgICBcbiAgICAgIC8vIFNob3cgYnJvd3NlciBub3RpZmljYXRpb24gaWYgZW5hYmxlZFxuICAgICAgaWYgKHVzZVN0b3JlLmdldFN0YXRlKCkubm90aWZpY2F0aW9ucyAmJiAnTm90aWZpY2F0aW9uJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgaWYgKE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZ3JhbnRlZCcpIHtcbiAgICAgICAgICBuZXcgTm90aWZpY2F0aW9uKGFsZXJ0LnRpdGxlLCB7XG4gICAgICAgICAgICBib2R5OiBhbGVydC5tZXNzYWdlLFxuICAgICAgICAgICAgaWNvbjogJy9mYXZpY29uLnN2ZycsXG4gICAgICAgICAgICB0YWc6IGFsZXJ0LnR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLnNvY2tldC5vbignc2NlbmFyaW9zX3VwZGF0ZScsIChzY2VuYXJpb3M6IGFueVtdKSA9PiB7XG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnNldFNjZW5hcmlvcyhzY2VuYXJpb3MgYXMgYW55KVxuICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS51cGRhdGVMYXN0VXBkYXRlKClcbiAgICB9KVxuXG4gICAgLy8gR2hhbmEtc3BlY2lmaWMgZXZlbnRzXG4gICAgdGhpcy5zb2NrZXQub24oJ2doYW5hX3dlYXRoZXJfdXBkYXRlJywgKHdlYXRoZXI6IGFueSkgPT4ge1xuICAgICAgLy8gSGFuZGxlIHdlYXRoZXIgdXBkYXRlcyB0aGF0IG1pZ2h0IGFmZmVjdCB0cmFuc3BvcnRcbiAgICAgIGlmICh3ZWF0aGVyLmlzX3JhaW55ICYmIHdlYXRoZXIucmFpbl9pbnRlbnNpdHkgPT09ICdoaWdoJykge1xuICAgICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLmFkZEFsZXJ0KHtcbiAgICAgICAgICB0eXBlOiAnd2FybmluZycsXG4gICAgICAgICAgdGl0bGU6ICdIZWF2eSBSYWluIEFsZXJ0JyxcbiAgICAgICAgICBtZXNzYWdlOiAnSGVhdnkgcmFpbmZhbGwgZGV0ZWN0ZWQgaW4gQWNjcmEuIEV4cGVjdCB0cmFmZmljIGRlbGF5cyBhbmQgcG90ZW50aWFsIGZsb29kaW5nLicsXG4gICAgICAgICAgcmVhZDogZmFsc2UsXG4gICAgICAgIH0gYXMgYW55KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLnNvY2tldC5vbignZ2hhbmFfaG9saWRheV9hbGVydCcsIChob2xpZGF5OiBhbnkpID0+IHtcbiAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkuYWRkQWxlcnQoe1xuICAgICAgICB0eXBlOiAnaW5mbycsXG4gICAgICAgIHRpdGxlOiAnR2hhbmEgUHVibGljIEhvbGlkYXknLFxuICAgICAgICBtZXNzYWdlOiBgVG9kYXkgaXMgJHtob2xpZGF5Lm5hbWV9LiBFeHBlY3QgcmVkdWNlZCB0cmFuc3BvcnQgc2VydmljZXMuYCxcbiAgICAgICAgcmVhZDogZmFsc2UsXG4gICAgICB9IGFzIGFueSlcbiAgICB9KVxuXG4gICAgdGhpcy5zb2NrZXQub24oJ2NyaXNpc19zY2VuYXJpbycsIChzY2VuYXJpbzogYW55KSA9PiB7XG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLmFkZEFsZXJ0KHtcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgdGl0bGU6ICdDcmlzaXMgQWxlcnQnLFxuICAgICAgICBtZXNzYWdlOiBgJHtzY2VuYXJpby5uYW1lfTogJHtzY2VuYXJpby5kZXNjcmlwdGlvbn1gLFxuICAgICAgICByZWFkOiBmYWxzZSxcbiAgICAgIH0gYXMgYW55KVxuICAgIH0pXG5cbiAgICAvLyBNTC9BSSBldmVudHMgKFBoYXNlIDMpXG4gICAgdGhpcy5zb2NrZXQub24oJ21sX3ByZWRpY3Rpb24nLCAocHJlZGljdGlvbjogYW55KSA9PiB7XG4gICAgICBjb25zdCBtbFByZWRpY3Rpb24gPSB7XG4gICAgICAgIC4uLnByZWRpY3Rpb24sXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUocHJlZGljdGlvbi50aW1lc3RhbXApXG4gICAgICB9XG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLmFkZE1MUHJlZGljdGlvbihtbFByZWRpY3Rpb24pXG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnVwZGF0ZUxhc3RVcGRhdGUoKVxuICAgIH0pXG5cbiAgICB0aGlzLnNvY2tldC5vbignYW5vbWFseV9kZXRlY3RlZCcsIChhbm9tYWx5OiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IGFub21hbHlFdmVudCA9IHtcbiAgICAgICAgLi4uYW5vbWFseSxcbiAgICAgICAgZGV0ZWN0ZWRfYXQ6IG5ldyBEYXRlKGFub21hbHkuZGV0ZWN0ZWRfYXQpXG4gICAgICB9XG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLmFkZEFub21hbHkoYW5vbWFseUV2ZW50KVxuXG4gICAgICAvLyBDcmVhdGUgYWxlcnQgZm9yIGhpZ2ggc2V2ZXJpdHkgYW5vbWFsaWVzXG4gICAgICBpZiAoYW5vbWFseS5zZXZlcml0eSA9PT0gJ2hpZ2gnIHx8IGFub21hbHkuc2V2ZXJpdHkgPT09ICdjcml0aWNhbCcpIHtcbiAgICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS5hZGRBbGVydCh7XG4gICAgICAgICAgdHlwZTogYW5vbWFseS5zZXZlcml0eSA9PT0gJ2NyaXRpY2FsJyA/ICdlcnJvcicgOiAnd2FybmluZycsXG4gICAgICAgICAgdGl0bGU6IGBBbm9tYWx5IERldGVjdGVkOiAke2Fub21hbHkudGl0bGV9YCxcbiAgICAgICAgICBtZXNzYWdlOiBhbm9tYWx5LmRlc2NyaXB0aW9uLFxuICAgICAgICAgIHJlYWQ6IGZhbHNlLFxuICAgICAgICB9IGFzIGFueSlcbiAgICAgIH1cblxuICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS51cGRhdGVMYXN0VXBkYXRlKClcbiAgICB9KVxuXG4gICAgdGhpcy5zb2NrZXQub24oJ2FpX2luc2lnaHRzJywgKGluc2lnaHRzOiBhbnkpID0+IHtcbiAgICAgIC8vIEFkZCBpbmRpdmlkdWFsIGluc2lnaHRzXG4gICAgICBpZiAoaW5zaWdodHMuaW5zaWdodHMpIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhpbnNpZ2h0cy5pbnNpZ2h0cykuZmxhdCgpLmZvckVhY2goKGluc2lnaHQ6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGFpSW5zaWdodCA9IHtcbiAgICAgICAgICAgIC4uLmluc2lnaHQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKGluc2lnaHQudGltZXN0YW1wIHx8IERhdGUubm93KCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkuYWRkQUlJbnNpZ2h0KGFpSW5zaWdodClcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS51cGRhdGVMYXN0VXBkYXRlKClcbiAgICB9KVxuXG4gICAgdGhpcy5zb2NrZXQub24oJ3NjZW5hcmlvX2FuYWx5c2lzJywgKGFuYWx5c2lzOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvQW5hbHlzaXMgPSB7XG4gICAgICAgIC4uLmFuYWx5c2lzLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgIH1cbiAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkuYWRkU2NlbmFyaW9BbmFseXNpcyhzY2VuYXJpb0FuYWx5c2lzKVxuICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS51cGRhdGVMYXN0VXBkYXRlKClcbiAgICB9KVxuXG4gICAgdGhpcy5zb2NrZXQub24oJ2N1bHR1cmFsX2luc2lnaHRzJywgKGluc2lnaHRzOiBhbnkpID0+IHtcbiAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkuc2V0Q3VsdHVyYWxJbnNpZ2h0cyhpbnNpZ2h0cylcbiAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkudXBkYXRlTGFzdFVwZGF0ZSgpXG4gICAgfSlcblxuICAgIHRoaXMuc29ja2V0Lm9uKCdlY29ub21pY19hbmFseXNpcycsIChhbmFseXNpczogYW55KSA9PiB7XG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnNldEVjb25vbWljQW5hbHlzaXMoYW5hbHlzaXMpXG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnVwZGF0ZUxhc3RVcGRhdGUoKVxuICAgIH0pXG4gIH1cblxuICAvLyBSZW1vdmVkIGhhbmRsZVJlY29ubmVjdCAtIFNvY2tldC5JTyBoYW5kbGVzIHJlY29ubmVjdGlvbiBhdXRvbWF0aWNhbGx5XG5cbiAgLy8gRW1pdCBldmVudHMgdG8gc2VydmVyXG4gIGVtaXQoZXZlbnQ6IHN0cmluZywgZGF0YT86IGFueSkge1xuICAgIGlmICh0aGlzLnNvY2tldD8uY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnNvY2tldC5lbWl0KGV2ZW50LCBkYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dlYlNvY2tldCBub3QgY29ubmVjdGVkLCBjYW5ub3QgZW1pdCBldmVudDonLCBldmVudClcbiAgICB9XG4gIH1cblxuICAvLyBTY2VuYXJpbyBjb250cm9sXG4gIGFjdGl2YXRlU2NlbmFyaW8oc2NlbmFyaW9JZDogc3RyaW5nLCBwYXJhbWV0ZXJzPzogYW55KSB7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmF0ZV9zY2VuYXJpbycsIHsgc2NlbmFyaW9JZCwgcGFyYW1ldGVycyB9KVxuICB9XG5cbiAgZGVhY3RpdmF0ZVNjZW5hcmlvKHNjZW5hcmlvSWQ6IHN0cmluZykge1xuICAgIHRoaXMuZW1pdCgnZGVhY3RpdmF0ZV9zY2VuYXJpbycsIHsgc2NlbmFyaW9JZCB9KVxuICB9XG5cbiAgLy8gUmVxdWVzdCBkYXRhIHVwZGF0ZXNcbiAgcmVxdWVzdFZlaGljbGVVcGRhdGUoKSB7XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0X3ZlaGljbGVzJylcbiAgfVxuXG4gIHJlcXVlc3RSb3V0ZVVwZGF0ZSgpIHtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3Rfcm91dGVzJylcbiAgfVxuXG4gIHJlcXVlc3RLUElVcGRhdGUoKSB7XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0X2twaXMnKVxuICB9XG5cbiAgLy8gU2VuZCB1c2VyIHByZWZlcmVuY2VzXG4gIHVwZGF0ZVVzZXJQcmVmZXJlbmNlcyhwcmVmZXJlbmNlczogYW55KSB7XG4gICAgdGhpcy5lbWl0KCd1c2VyX3ByZWZlcmVuY2VzJywgcHJlZmVyZW5jZXMpXG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuaXNNYW51YWxEaXNjb25uZWN0ID0gdHJ1ZVxuICAgIHRoaXMuY29ubmVjdGlvblN0YXR1cyA9ICdkaXNjb25uZWN0ZWQnXG5cbiAgICBjb25zb2xlLmxvZygn8J+nuSBXZWJTb2NrZXQ6IFN0YXJ0aW5nIGNvbXByZWhlbnNpdmUgY2xlYW51cC4uLicpXG5cbiAgICAvLyBDbGVhciBhbGwgdGltZXJzIHdpdGggbWVtb3J5IGxlYWsgcHJldmVudGlvblxuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIHRoaXMubWVtb3J5RGV0ZWN0b3IuY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dClcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oZWFydGJlYXRJbnRlcnZhbCkge1xuICAgICAgdGhpcy5tZW1vcnlEZXRlY3Rvci5jbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpXG4gICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsID0gbnVsbFxuICAgIH1cblxuICAgIGlmICh0aGlzLnNvY2tldCkge1xuICAgICAgY29uc29sZS5sb2coJ/CflIwgRGlzY29ubmVjdGluZyBXZWJTb2NrZXQuLi4nKVxuXG4gICAgICAvLyBSZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKClcblxuICAgICAgLy8gRGlzY29ubmVjdCB0aGUgc29ja2V0XG4gICAgICB0aGlzLnNvY2tldC5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuc29ja2V0ID0gbnVsbFxuXG4gICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnNldENvbm5lY3Rpb25TdGF0dXMoJ2Rpc2Nvbm5lY3RlZCcpXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFdlYlNvY2tldCBjbGVhbnVwIGNvbXBsZXRlZCcpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZVJlY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5pc01hbnVhbERpc2Nvbm5lY3QgfHwgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA+PSB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+aqyBOb3Qgc2NoZWR1bGluZyByZWNvbm5lY3QgLSBtYW51YWwgZGlzY29ubmVjdCBvciBtYXggYXR0ZW1wdHMgcmVhY2hlZCcpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKytcbiAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKHRoaXMucmVjb25uZWN0RGVsYXkgKiBNYXRoLnBvdygyLCB0aGlzLnJlY29ubmVjdEF0dGVtcHRzIC0gMSksIDMwMDAwKSAvLyBNYXggMzAgc2Vjb25kc1xuXG4gICAgY29uc29sZS5sb2coYPCflIQgU2NoZWR1bGluZyByZWNvbm5lY3QgYXR0ZW1wdCAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9LyR7dGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0c30gaW4gJHtkZWxheX1tc2ApXG5cbiAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc01hbnVhbERpc2Nvbm5lY3QpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgUmVjb25uZWN0IGF0dGVtcHQgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfS8ke3RoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHN9YClcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMuY29ubmVjdGlvblVybClcbiAgICAgIH1cbiAgICB9LCBkZWxheSlcbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRIZWFydGJlYXQoKSB7XG4gICAgaWYgKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRJbnRlcnZhbClcbiAgICB9XG5cbiAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc29ja2V0ICYmIHRoaXMuc29ja2V0LmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdwaW5nJylcbiAgICAgIH1cbiAgICB9LCAzMDAwMCkgLy8gUGluZyBldmVyeSAzMCBzZWNvbmRzXG4gIH1cblxuICBpc0Nvbm5lY3RlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zb2NrZXQ/LmNvbm5lY3RlZCB8fCBmYWxzZVxuICB9XG5cbiAgZ2V0Q29ubmVjdGlvblN0YXR1cygpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5zb2NrZXQpIHJldHVybiAnZGlzY29ubmVjdGVkJ1xuICAgIGlmICh0aGlzLnNvY2tldC5jb25uZWN0ZWQpIHJldHVybiAnY29ubmVjdGVkJ1xuICAgIGlmICh0aGlzLnNvY2tldC5jb25uZWN0aW5nKSByZXR1cm4gJ2Nvbm5lY3RpbmcnXG4gICAgcmV0dXJuICdkaXNjb25uZWN0ZWQnXG4gIH1cblxuICBnZXRTb2NrZXQoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5zb2NrZXRcbiAgfVxufVxuXG4vLyBTaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCB3ZWJzb2NrZXRTZXJ2aWNlID0gbmV3IFdlYlNvY2tldFNlcnZpY2UoKVxuXG4vLyBIb29rIGZvciBlYXN5IGFjY2VzcyBpbiBjb21wb25lbnRzXG5leHBvcnQgY29uc3QgdXNlV2ViU29ja2V0ID0gKCkgPT4ge1xuICBjb25zdCBjb25uZWN0ZWQgPSB1c2VTdG9yZSgoc3RhdGUpID0+IHN0YXRlLmNvbm5lY3RlZClcbiAgY29uc3QgY29ubmVjdGlvblN0YXR1cyA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUuY29ubmVjdGlvblN0YXR1cylcbiAgY29uc3QgbGFzdFVwZGF0ZSA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUubGFzdFVwZGF0ZSlcblxuICByZXR1cm4ge1xuICAgIGNvbm5lY3RlZCxcbiAgICBjb25uZWN0aW9uU3RhdHVzLFxuICAgIGxhc3RVcGRhdGUsXG4gICAgY29ubmVjdDogd2Vic29ja2V0U2VydmljZS5jb25uZWN0LmJpbmQod2Vic29ja2V0U2VydmljZSksXG4gICAgZGlzY29ubmVjdDogd2Vic29ja2V0U2VydmljZS5kaXNjb25uZWN0LmJpbmQod2Vic29ja2V0U2VydmljZSksXG4gICAgZW1pdDogd2Vic29ja2V0U2VydmljZS5lbWl0LmJpbmQod2Vic29ja2V0U2VydmljZSksXG4gICAgYWN0aXZhdGVTY2VuYXJpbzogd2Vic29ja2V0U2VydmljZS5hY3RpdmF0ZVNjZW5hcmlvLmJpbmQod2Vic29ja2V0U2VydmljZSksXG4gICAgZGVhY3RpdmF0ZVNjZW5hcmlvOiB3ZWJzb2NrZXRTZXJ2aWNlLmRlYWN0aXZhdGVTY2VuYXJpby5iaW5kKHdlYnNvY2tldFNlcnZpY2UpLFxuICAgIHJlcXVlc3RWZWhpY2xlVXBkYXRlOiB3ZWJzb2NrZXRTZXJ2aWNlLnJlcXVlc3RWZWhpY2xlVXBkYXRlLmJpbmQod2Vic29ja2V0U2VydmljZSksXG4gICAgcmVxdWVzdFJvdXRlVXBkYXRlOiB3ZWJzb2NrZXRTZXJ2aWNlLnJlcXVlc3RSb3V0ZVVwZGF0ZS5iaW5kKHdlYnNvY2tldFNlcnZpY2UpLFxuICAgIHJlcXVlc3RLUElVcGRhdGU6IHdlYnNvY2tldFNlcnZpY2UucmVxdWVzdEtQSVVwZGF0ZS5iaW5kKHdlYnNvY2tldFNlcnZpY2UpLFxuICB9XG59XG5cbi8vIEV4cG9ydCB0aGUgc2VydmljZSB3aXRob3V0IGF1dG8tY29ubmVjdGluZ1xuLy8gQ29tcG9uZW50cyB3aWxsIGNvbm5lY3QgbWFudWFsbHkgd2hlbiBuZWVkZWRcbiJdLCJuYW1lcyI6WyJNZW1vcnlMZWFrRGV0ZWN0b3IiLCJ1c2VTdG9yZSIsImlvIiwiV2ViU29ja2V0U2VydmljZSIsImdldFdlYlNvY2tldFVybCIsImlzRGV2IiwicHJvY2VzcyIsIndpbmRvdyIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsImNvbm5lY3QiLCJ1cmwiLCJkZWZhdWx0VXJsIiwidGFyZ2V0VXJsIiwiY29ubmVjdGlvblVybCIsImlzTWFudWFsRGlzY29ubmVjdCIsImNvbnNvbGUiLCJsb2ciLCJocmVmIiwicmVjb25uZWN0VGltZW91dCIsImNsZWFyVGltZW91dCIsImNvbm5lY3Rpb25TdGF0dXMiLCJzb2NrZXQiLCJkaXNjb25uZWN0IiwidHJhbnNwb3J0cyIsInRpbWVvdXQiLCJmb3JjZU5ldyIsImF1dG9Db25uZWN0IiwicmVjb25uZWN0aW9uIiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJyZWNvbm5lY3Rpb25EZWxheSIsInJlY29ubmVjdGlvbkRlbGF5TWF4IiwicmFuZG9taXphdGlvbkZhY3RvciIsInVwZ3JhZGUiLCJyZW1lbWJlclVwZ3JhZGUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJleHRyYUhlYWRlcnMiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwiZ2V0U3RhdGUiLCJzZXRDb25uZWN0aW9uU3RhdHVzIiwiZXJyb3IiLCJvbiIsImlkIiwiZW5naW5lIiwidHJhbnNwb3J0IiwibmFtZSIsInJlY29ubmVjdEF0dGVtcHRzIiwidXBkYXRlTGFzdFVwZGF0ZSIsInN0YXJ0SGVhcnRiZWF0IiwicmVhc29uIiwiaGVhcnRiZWF0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwic2NoZWR1bGVSZWNvbm5lY3QiLCJtZXNzYWdlIiwidHlwZSIsImNvbnN0cnVjdG9yIiwic3RhY2siLCJjb25uZWN0ZWQiLCJkaXNjb25uZWN0ZWQiLCJ2ZWhpY2xlcyIsInNldFZlaGljbGVzIiwidXBkYXRlcyIsInVwZGF0ZVZlaGljbGUiLCJyb3V0ZXMiLCJzZXRSb3V0ZXMiLCJ1cGRhdGVSb3V0ZSIsImtwaXMiLCJzZXRLUElzIiwidHJpcHMiLCJsZW5ndGgiLCJzZXRUcmlwcyIsInZhbHVlIiwicGFyc2VGbG9hdCIsInVwZGF0ZUtQSSIsImFsZXJ0IiwiYWRkQWxlcnQiLCJub3RpZmljYXRpb25zIiwiTm90aWZpY2F0aW9uIiwicGVybWlzc2lvbiIsInRpdGxlIiwiYm9keSIsImljb24iLCJ0YWciLCJzY2VuYXJpb3MiLCJzZXRTY2VuYXJpb3MiLCJ3ZWF0aGVyIiwiaXNfcmFpbnkiLCJyYWluX2ludGVuc2l0eSIsInJlYWQiLCJob2xpZGF5Iiwic2NlbmFyaW8iLCJkZXNjcmlwdGlvbiIsInByZWRpY3Rpb24iLCJtbFByZWRpY3Rpb24iLCJ0aW1lc3RhbXAiLCJEYXRlIiwiYWRkTUxQcmVkaWN0aW9uIiwiYW5vbWFseSIsImFub21hbHlFdmVudCIsImRldGVjdGVkX2F0IiwiYWRkQW5vbWFseSIsInNldmVyaXR5IiwiaW5zaWdodHMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmbGF0IiwiZm9yRWFjaCIsImluc2lnaHQiLCJhaUluc2lnaHQiLCJub3ciLCJhZGRBSUluc2lnaHQiLCJhbmFseXNpcyIsInNjZW5hcmlvQW5hbHlzaXMiLCJhZGRTY2VuYXJpb0FuYWx5c2lzIiwic2V0Q3VsdHVyYWxJbnNpZ2h0cyIsInNldEVjb25vbWljQW5hbHlzaXMiLCJlbWl0IiwiZXZlbnQiLCJkYXRhIiwid2FybiIsImFjdGl2YXRlU2NlbmFyaW8iLCJzY2VuYXJpb0lkIiwicGFyYW1ldGVycyIsImRlYWN0aXZhdGVTY2VuYXJpbyIsInJlcXVlc3RWZWhpY2xlVXBkYXRlIiwicmVxdWVzdFJvdXRlVXBkYXRlIiwicmVxdWVzdEtQSVVwZGF0ZSIsInVwZGF0ZVVzZXJQcmVmZXJlbmNlcyIsInByZWZlcmVuY2VzIiwibWVtb3J5RGV0ZWN0b3IiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJtYXhSZWNvbm5lY3RBdHRlbXB0cyIsImRlbGF5IiwiTWF0aCIsIm1pbiIsInJlY29ubmVjdERlbGF5IiwicG93Iiwic2V0VGltZW91dCIsInNldEludGVydmFsIiwiaXNDb25uZWN0ZWQiLCJnZXRDb25uZWN0aW9uU3RhdHVzIiwiY29ubmVjdGluZyIsImdldFNvY2tldCIsImdldEluc3RhbmNlIiwid2Vic29ja2V0U2VydmljZSIsInVzZVdlYlNvY2tldCIsInN0YXRlIiwibGFzdFVwZGF0ZSIsImJpbmQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/websocket.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/store/useStore.ts":
/*!*******************************!*\
  !*** ./src/store/useStore.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useActiveScenarios: () => (/* binding */ useActiveScenarios),\n/* harmony export */   useKPIsByCategory: () => (/* binding */ useKPIsByCategory),\n/* harmony export */   useRouteVehicles: () => (/* binding */ useRouteVehicles),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useUnreadAlerts: () => (/* binding */ useUnreadAlerts)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n\n\n// Default Accra coordinates\nconst DEFAULT_CENTER = [\n    5.6037,\n    -0.1870\n];\nconst useStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.subscribeWithSelector)((set, get)=>({\n        // Initial state\n        vehicles: [],\n        routes: [],\n        trips: [],\n        kpis: [],\n        // Ghana GTFS Data\n        gtfsData: null,\n        gtfsLoaded: false,\n        gtfsError: null,\n        alerts: [],\n        scenarios: [],\n        // ML/AI initial state (Phase 3)\n        mlPredictions: [],\n        anomalies: [],\n        aiInsights: [],\n        scenarioAnalyses: [],\n        culturalInsights: null,\n        economicAnalysis: null,\n        selectedRoute: null,\n        selectedVehicle: null,\n        mapCenter: DEFAULT_CENTER,\n        mapZoom: 12,\n        sidebarOpen: true,\n        activePanel: 'overview',\n        connected: false,\n        connectionStatus: 'disconnected',\n        lastUpdate: null,\n        theme: 'light',\n        notifications: true,\n        autoRefresh: true,\n        refreshInterval: 30000,\n        // Data actions\n        setVehicles: (vehicles)=>set({\n                vehicles\n            }),\n        updateVehicle: (id, updates)=>set((state)=>({\n                    vehicles: state.vehicles.map((vehicle)=>vehicle.id === id ? {\n                            ...vehicle,\n                            ...updates\n                        } : vehicle)\n                })),\n        setRoutes: (routes)=>set({\n                routes\n            }),\n        updateRoute: (id, updates)=>set((state)=>({\n                    routes: state.routes.map((route)=>route.id === id ? {\n                            ...route,\n                            ...updates\n                        } : route)\n                })),\n        setTrips: (trips)=>set({\n                trips\n            }),\n        setKPIs: (kpis)=>set({\n                kpis\n            }),\n        updateKPI: (id, updates)=>set((state)=>({\n                    kpis: state.kpis.map((kpi)=>kpi.id === id ? {\n                            ...kpi,\n                            ...updates\n                        } : kpi)\n                })),\n        addAlert: (alert)=>set((state)=>({\n                    alerts: [\n                        {\n                            ...alert,\n                            id: Math.random().toString(36).substr(2, 9),\n                            timestamp: new Date()\n                        },\n                        ...state.alerts\n                    ]\n                })),\n        markAlertRead: (id)=>set((state)=>({\n                    alerts: state.alerts.map((alert)=>alert.id === id ? {\n                            ...alert,\n                            read: true\n                        } : alert)\n                })),\n        clearAlerts: ()=>set({\n                alerts: []\n            }),\n        setScenarios: (scenarios)=>set({\n                scenarios\n            }),\n        activateScenario: (id)=>set((state)=>({\n                    scenarios: state.scenarios.map((scenario)=>scenario.id === id ? {\n                            ...scenario,\n                            active: true\n                        } : scenario)\n                })),\n        deactivateScenario: (id)=>set((state)=>({\n                    scenarios: state.scenarios.map((scenario)=>scenario.id === id ? {\n                            ...scenario,\n                            active: false\n                        } : scenario)\n                })),\n        // ML/AI actions (Phase 3)\n        addMLPrediction: (prediction)=>set((state)=>({\n                    mlPredictions: [\n                        ...state.mlPredictions.slice(-99),\n                        prediction\n                    ] // Keep last 100\n                })),\n        addAnomaly: (anomaly)=>set((state)=>({\n                    anomalies: [\n                        ...state.anomalies.slice(-49),\n                        anomaly\n                    ] // Keep last 50\n                })),\n        addAIInsight: (insight)=>set((state)=>({\n                    aiInsights: [\n                        ...state.aiInsights.slice(-29),\n                        insight\n                    ] // Keep last 30\n                })),\n        addScenarioAnalysis: (analysis)=>set((state)=>({\n                    scenarioAnalyses: [\n                        ...state.scenarioAnalyses.slice(-19),\n                        analysis\n                    ] // Keep last 20\n                })),\n        setCulturalInsights: (insights)=>set({\n                culturalInsights: insights\n            }),\n        setEconomicAnalysis: (analysis)=>set({\n                economicAnalysis: analysis\n            }),\n        clearOldPredictions: ()=>set((state)=>{\n                const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n                return {\n                    mlPredictions: state.mlPredictions.filter((p)=>p.timestamp > oneHourAgo),\n                    anomalies: state.anomalies.filter((a)=>a.detected_at > oneHourAgo)\n                };\n            }),\n        // UI actions\n        selectRoute: (id)=>set({\n                selectedRoute: id\n            }),\n        selectVehicle: (id)=>set({\n                selectedVehicle: id\n            }),\n        setMapView: (center, zoom)=>set({\n                mapCenter: center,\n                mapZoom: zoom\n            }),\n        toggleSidebar: ()=>set((state)=>({\n                    sidebarOpen: !state.sidebarOpen\n                })),\n        setActivePanel: (panel)=>set({\n                activePanel: panel\n            }),\n        // Connection actions\n        setConnectionStatus: (status)=>set({\n                connectionStatus: status,\n                connected: status === 'connected'\n            }),\n        updateLastUpdate: ()=>set({\n                lastUpdate: new Date()\n            }),\n        // GTFS Data actions\n        setGTFSData: (data)=>set({\n                gtfsData: data,\n                gtfsLoaded: true,\n                gtfsError: null\n            }),\n        setGTFSError: (error)=>set({\n                gtfsError: error,\n                gtfsLoaded: false\n            }),\n        clearGTFSData: ()=>set({\n                gtfsData: null,\n                gtfsLoaded: false,\n                gtfsError: null\n            }),\n        // Preference actions\n        setTheme: (theme)=>set({\n                theme\n            }),\n        toggleNotifications: ()=>set((state)=>({\n                    notifications: !state.notifications\n                })),\n        setAutoRefresh: (enabled)=>set({\n                autoRefresh: enabled\n            }),\n        setRefreshInterval: (interval)=>set({\n                refreshInterval: interval\n            })\n    })));\n// Selectors for computed values\nconst useUnreadAlerts = ()=>useStore({\n        \"useUnreadAlerts.useStore\": (state)=>state.alerts.filter({\n                \"useUnreadAlerts.useStore\": (alert)=>!alert.read\n            }[\"useUnreadAlerts.useStore\"])\n    }[\"useUnreadAlerts.useStore\"]);\nconst useActiveScenarios = ()=>useStore({\n        \"useActiveScenarios.useStore\": (state)=>state.scenarios.filter({\n                \"useActiveScenarios.useStore\": (scenario)=>scenario.active\n            }[\"useActiveScenarios.useStore\"])\n    }[\"useActiveScenarios.useStore\"]);\nconst useRouteVehicles = (routeId)=>useStore({\n        \"useRouteVehicles.useStore\": (state)=>state.vehicles.filter({\n                \"useRouteVehicles.useStore\": (vehicle)=>vehicle.route === routeId\n            }[\"useRouteVehicles.useStore\"])\n    }[\"useRouteVehicles.useStore\"]);\nconst useKPIsByCategory = (category)=>useStore({\n        \"useKPIsByCategory.useStore\": (state)=>state.kpis.filter({\n                \"useKPIsByCategory.useStore\": (kpi)=>kpi.category === category\n            }[\"useKPIsByCategory.useStore\"])\n    }[\"useKPIsByCategory.useStore\"]);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS91c2VTdG9yZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWdDO0FBQzBCO0FBeVIxRCw0QkFBNEI7QUFDNUIsTUFBTUUsaUJBQW1DO0lBQUM7SUFBUSxDQUFDO0NBQU87QUFFbkQsTUFBTUMsV0FBV0gsK0NBQU1BLEdBQzVCQyx5RUFBcUJBLENBQUMsQ0FBQ0csS0FBS0MsTUFBUztRQUNuQyxnQkFBZ0I7UUFDaEJDLFVBQVUsRUFBRTtRQUNaQyxRQUFRLEVBQUU7UUFDVkMsT0FBTyxFQUFFO1FBQ1RDLE1BQU0sRUFBRTtRQUVSLGtCQUFrQjtRQUNsQkMsVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLFdBQVc7UUFDWEMsUUFBUSxFQUFFO1FBQ1ZDLFdBQVcsRUFBRTtRQUViLGdDQUFnQztRQUNoQ0MsZUFBZSxFQUFFO1FBQ2pCQyxXQUFXLEVBQUU7UUFDYkMsWUFBWSxFQUFFO1FBQ2RDLGtCQUFrQixFQUFFO1FBQ3BCQyxrQkFBa0I7UUFDbEJDLGtCQUFrQjtRQUVsQkMsZUFBZTtRQUNmQyxpQkFBaUI7UUFDakJDLFdBQVdyQjtRQUNYc0IsU0FBUztRQUNUQyxhQUFhO1FBQ2JDLGFBQWE7UUFFYkMsV0FBVztRQUNYQyxrQkFBa0I7UUFDbEJDLFlBQVk7UUFFWkMsT0FBTztRQUNQQyxlQUFlO1FBQ2ZDLGFBQWE7UUFDYkMsaUJBQWlCO1FBRWpCLGVBQWU7UUFDZkMsYUFBYSxDQUFDNUIsV0FBYUYsSUFBSTtnQkFBRUU7WUFBUztRQUUxQzZCLGVBQWUsQ0FBQ0MsSUFBSUMsVUFBWWpDLElBQUksQ0FBQ2tDLFFBQVc7b0JBQzlDaEMsVUFBVWdDLE1BQU1oQyxRQUFRLENBQUNpQyxHQUFHLENBQUNDLENBQUFBLFVBQzNCQSxRQUFRSixFQUFFLEtBQUtBLEtBQUs7NEJBQUUsR0FBR0ksT0FBTzs0QkFBRSxHQUFHSCxPQUFPO3dCQUFDLElBQUlHO2dCQUVyRDtRQUVBQyxXQUFXLENBQUNsQyxTQUFXSCxJQUFJO2dC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bVxcRGVza3RvcFxcYXVyYVxcc3JjXFxzdG9yZVxcdXNlU3RvcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCdcbmltcG9ydCB7IHN1YnNjcmliZVdpdGhTZWxlY3RvciB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSdcblxuLy8gVHlwZXMgZm9yIG91ciBzdG9yZVxuZXhwb3J0IGludGVyZmFjZSBWZWhpY2xlIHtcbiAgaWQ6IHN0cmluZ1xuICByb3V0ZTogc3RyaW5nXG4gIGxhdDogbnVtYmVyXG4gIGxuZzogbnVtYmVyXG4gIHNwZWVkOiBudW1iZXJcbiAgcGFzc2VuZ2VyczogbnVtYmVyXG4gIGNhcGFjaXR5OiBudW1iZXJcbiAgc3RhdHVzOiAnYWN0aXZlJyB8ICdpZGxlJyB8ICdtYWludGVuYW5jZSdcbiAgbGFzdFVwZGF0ZTogRGF0ZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlIHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgY29sb3I6IHN0cmluZ1xuICBzdG9wczogQXJyYXk8e1xuICAgIGlkOiBzdHJpbmdcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBsYXQ6IG51bWJlclxuICAgIGxuZzogbnVtYmVyXG4gICAgcGFzc2VuZ2Vyc193YWl0aW5nOiBudW1iZXJcbiAgfT5cbiAgdmVoaWNsZXM6IHN0cmluZ1tdXG4gIHN0YXR1czogJ2FjdGl2ZScgfCAnZGlzcnVwdGVkJyB8ICdtYWludGVuYW5jZSdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBLUEkge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICB2YWx1ZTogbnVtYmVyXG4gIGNoYW5nZTogbnVtYmVyXG4gIHRyZW5kOiAndXAnIHwgJ2Rvd24nIHwgJ25ldXRyYWwnXG4gIHVuaXQ6IHN0cmluZ1xuICBjYXRlZ29yeTogJ2VmZmljaWVuY3knIHwgJ2ZpbmFuY2lhbCcgfCAnZW52aXJvbm1lbnRhbCcgfCAnc29jaWFsJ1xufVxuXG4vLyBHVEZTIERhdGEgVHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgR1RGU1JvdXRlIHtcbiAgcm91dGVfaWQ6IHN0cmluZ1xuICByb3V0ZV9zaG9ydF9uYW1lOiBzdHJpbmdcbiAgcm91dGVfbG9uZ19uYW1lOiBzdHJpbmdcbiAgcm91dGVfdHlwZTogbnVtYmVyXG4gIHJvdXRlX2NvbG9yPzogc3RyaW5nXG4gIHNoYXBlX2lkPzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR1RGU1N0b3Age1xuICBzdG9wX2lkOiBzdHJpbmdcbiAgc3RvcF9uYW1lOiBzdHJpbmdcbiAgc3RvcF9sYXQ6IHN0cmluZ1xuICBzdG9wX2xvbjogc3RyaW5nXG4gIHN0b3BfY29kZT86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdURlNTdG9wVGltZSB7XG4gIHRyaXBfaWQ6IHN0cmluZ1xuICBhcnJpdmFsX3RpbWU6IHN0cmluZ1xuICBkZXBhcnR1cmVfdGltZTogc3RyaW5nXG4gIHN0b3BfaWQ6IHN0cmluZ1xuICBzdG9wX3NlcXVlbmNlOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHVEZTU2hhcGUge1xuICBzaGFwZV9pZDogc3RyaW5nXG4gIHNoYXBlX3B0X2xhdDogc3RyaW5nXG4gIHNoYXBlX3B0X2xvbjogc3RyaW5nXG4gIHNoYXBlX3B0X3NlcXVlbmNlOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHVEZTRGF0YSB7XG4gIHJvdXRlczogR1RGU1JvdXRlW11cbiAgc3RvcHM6IEdURlNTdG9wW11cbiAgc3RvcF90aW1lczogR1RGU1N0b3BUaW1lW11cbiAgc2hhcGVzOiBHVEZTU2hhcGVbXVxuICB0cmlwczogR1RGU1RyaXBbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdURlNUcmlwIHtcbiAgdHJpcF9pZDogc3RyaW5nXG4gIHJvdXRlX2lkOiBzdHJpbmdcbiAgc2VydmljZV9pZDogc3RyaW5nXG4gIHNoYXBlX2lkOiBzdHJpbmdcbiAgcm91dGVfaW5mbzoge1xuICAgIHJvdXRlX3Nob3J0X25hbWU6IHN0cmluZ1xuICAgIHJvdXRlX2xvbmdfbmFtZTogc3RyaW5nXG4gICAgcm91dGVfdHlwZTogbnVtYmVyXG4gIH1cbiAgc3RvcF90aW1lczogQXJyYXk8e1xuICAgIHN0b3BfaWQ6IHN0cmluZ1xuICAgIGFycml2YWxfdGltZTogc3RyaW5nXG4gICAgZGVwYXJ0dXJlX3RpbWU6IHN0cmluZ1xuICAgIHN0b3Bfc2VxdWVuY2U6IG51bWJlclxuICB9PlxuICBzdGF0dXM6ICdhY3RpdmUnIHwgJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJ1xuICBsYXN0X3VwZGF0ZWQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFsZXJ0IHtcbiAgaWQ6IHN0cmluZ1xuICB0eXBlOiAnaW5mbycgfCAnd2FybmluZycgfCAnZXJyb3InIHwgJ3N1Y2Nlc3MnXG4gIHRpdGxlOiBzdHJpbmdcbiAgbWVzc2FnZTogc3RyaW5nXG4gIHRpbWVzdGFtcDogRGF0ZVxuICByZWFkOiBib29sZWFuXG4gIGFjdGlvbnM/OiBBcnJheTx7XG4gICAgbGFiZWw6IHN0cmluZ1xuICAgIGFjdGlvbjogKCkgPT4gdm9pZFxuICB9PlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjZW5hcmlvIHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgdHlwZTogJ2NyaXNpcycgfCAnb3B0aW1pemF0aW9uJyB8ICdzaW11bGF0aW9uJ1xuICBhY3RpdmU6IGJvb2xlYW5cbiAgcGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgYW55PlxuICBpbXBhY3Q6IHtcbiAgICByb3V0ZXM6IHN0cmluZ1tdXG4gICAgZXN0aW1hdGVkX2RlbGF5OiBudW1iZXJcbiAgICBhZmZlY3RlZF9wYXNzZW5nZXJzOiBudW1iZXJcbiAgfVxufVxuXG4vLyBOZXcgTUwvQUkgaW50ZXJmYWNlcyBmb3IgUGhhc2UgMyBpbnRlZ3JhdGlvblxuZXhwb3J0IGludGVyZmFjZSBNTFByZWRpY3Rpb24ge1xuICBwcmVkaWN0aW9uX3R5cGU6IHN0cmluZ1xuICB2YWx1ZTogbnVtYmVyXG4gIGNvbmZpZGVuY2U6IG51bWJlclxuICB0aW1lc3RhbXA6IERhdGVcbiAgY29udGV4dDogUmVjb3JkPHN0cmluZywgYW55PlxuICBtZXRhZGF0YTogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFub21hbHlFdmVudCB7XG4gIGFub21hbHlfaWQ6IHN0cmluZ1xuICB0eXBlOiBzdHJpbmdcbiAgc2V2ZXJpdHk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAnY3JpdGljYWwnXG4gIHRpdGxlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBhZmZlY3RlZF9yb3V0ZXM6IHN0cmluZ1tdXG4gIGRldGVjdGVkX2F0OiBEYXRlXG4gIGNvbmZpZGVuY2U6IG51bWJlclxuICBiYXNlbGluZV92YWx1ZTogbnVtYmVyXG4gIGN1cnJlbnRfdmFsdWU6IG51bWJlclxuICBkZXZpYXRpb25fcGVyY2VudGFnZTogbnVtYmVyXG4gIHByZWRpY3RlZF9pbXBhY3Q6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgcmVjb21tZW5kZWRfYWN0aW9uczogc3RyaW5nW11cbiAgZ2hhbmFfY29udGV4dDogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFJSW5zaWdodCB7XG4gIGluc2lnaHRfaWQ6IHN0cmluZ1xuICB0eXBlOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIGNvbmZpZGVuY2U6IG51bWJlclxuICBpbXBhY3RfbGV2ZWw6IHN0cmluZ1xuICByZWNvbW1lbmRhdGlvbnM6IHN0cmluZ1tdXG4gIGRhdGFfc291cmNlczogc3RyaW5nW11cbiAgdGltZXN0YW1wOiBEYXRlXG4gIGdoYW5hX2NvbnRleHQ6IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2VuYXJpb0FuYWx5c2lzIHtcbiAgc2NlbmFyaW9faWQ6IHN0cmluZ1xuICBzY2VuYXJpb19uYW1lOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBwcmVkaWN0ZWRfb3V0Y29tZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgcmlza19hc3Nlc3NtZW50OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIG1pdGlnYXRpb25fc3RyYXRlZ2llczogc3RyaW5nW11cbiAgZWNvbm9taWNfaW1wYWN0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHRpbWVsaW5lOiBzdHJpbmdcbiAgY29uZmlkZW5jZTogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VsdHVyYWxJbnNpZ2h0cyB7XG4gIHRpbWVzdGFtcDogc3RyaW5nXG4gIGN1bHR1cmFsX2ZhY3RvcnM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgZWNvbm9taWNfaW5kaWNhdG9yczogUmVjb3JkPHN0cmluZywgYW55PlxuICByZWNvbW1lbmRhdGlvbnM6IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWNvbm9taWNBbmFseXNpcyB7XG4gIHRpbWVzdGFtcDogc3RyaW5nXG4gIGJhc2VsaW5lX2Vjb25vbWljczogUmVjb3JkPHN0cmluZywgYW55PlxuICBvcHRpbWl6YXRpb25fYmVuZWZpdHM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgdG90YWxfaW1wYWN0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbmludGVyZmFjZSBBcHBTdGF0ZSB7XG4gIC8vIFJlYWwtdGltZSBkYXRhXG4gIHZlaGljbGVzOiBWZWhpY2xlW11cbiAgcm91dGVzOiBSb3V0ZVtdXG4gIHRyaXBzOiBHVEZTVHJpcFtdXG4gIGtwaXM6IEtQSVtdXG5cbiAgLy8gR2hhbmEgR1RGUyBEYXRhXG4gIGd0ZnNEYXRhOiBHVEZTRGF0YSB8IG51bGxcbiAgZ3Rmc0xvYWRlZDogYm9vbGVhblxuICBndGZzRXJyb3I6IHN0cmluZyB8IG51bGxcbiAgYWxlcnRzOiBBbGVydFtdXG4gIHNjZW5hcmlvczogU2NlbmFyaW9bXVxuXG4gIC8vIE1ML0FJIGRhdGEgKFBoYXNlIDMpXG4gIG1sUHJlZGljdGlvbnM6IE1MUHJlZGljdGlvbltdXG4gIGFub21hbGllczogQW5vbWFseUV2ZW50W11cbiAgYWlJbnNpZ2h0czogQUlJbnNpZ2h0W11cbiAgc2NlbmFyaW9BbmFseXNlczogU2NlbmFyaW9BbmFseXNpc1tdXG4gIGN1bHR1cmFsSW5zaWdodHM6IEN1bHR1cmFsSW5zaWdodHMgfCBudWxsXG4gIGVjb25vbWljQW5hbHlzaXM6IEVjb25vbWljQW5hbHlzaXMgfCBudWxsXG4gIFxuICAvLyBVSSBzdGF0ZVxuICBzZWxlY3RlZFJvdXRlOiBzdHJpbmcgfCBudWxsXG4gIHNlbGVjdGVkVmVoaWNsZTogc3RyaW5nIHwgbnVsbFxuICBtYXBDZW50ZXI6IFtudW1iZXIsIG51bWJlcl1cbiAgbWFwWm9vbTogbnVtYmVyXG4gIHNpZGViYXJPcGVuOiBib29sZWFuXG4gIGFjdGl2ZVBhbmVsOiAnb3ZlcnZpZXcnIHwgJ3JvdXRlcycgfCAndmVoaWNsZXMnIHwgJ2FuYWx5dGljcycgfCAnYWxlcnRzJ1xuICBcbiAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgY29ubmVjdGVkOiBib29sZWFuXG4gIGNvbm5lY3Rpb25TdGF0dXM6ICdjb25uZWN0aW5nJyB8ICdjb25uZWN0ZWQnIHwgJ2Rpc2Nvbm5lY3RlZCcgfCAnZXJyb3InXG4gIGxhc3RVcGRhdGU6IERhdGUgfCBudWxsXG4gIFxuICAvLyBVc2VyIHByZWZlcmVuY2VzXG4gIHRoZW1lOiAnbGlnaHQnIHwgJ2RhcmsnXG4gIG5vdGlmaWNhdGlvbnM6IGJvb2xlYW5cbiAgYXV0b1JlZnJlc2g6IGJvb2xlYW5cbiAgcmVmcmVzaEludGVydmFsOiBudW1iZXJcbiAgXG4gIC8vIEFjdGlvbnNcbiAgc2V0VmVoaWNsZXM6ICh2ZWhpY2xlczogVmVoaWNsZVtdKSA9PiB2b2lkXG4gIHVwZGF0ZVZlaGljbGU6IChpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFZlaGljbGU+KSA9PiB2b2lkXG4gIHNldFJvdXRlczogKHJvdXRlczogUm91dGVbXSkgPT4gdm9pZFxuICB1cGRhdGVSb3V0ZTogKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8Um91dGU+KSA9PiB2b2lkXG4gIHNldFRyaXBzOiAodHJpcHM6IEdURlNUcmlwW10pID0+IHZvaWRcbiAgc2V0S1BJczogKGtwaXM6IEtQSVtdKSA9PiB2b2lkXG4gIHVwZGF0ZUtQSTogKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8S1BJPikgPT4gdm9pZFxuICBhZGRBbGVydDogKGFsZXJ0OiBPbWl0PEFsZXJ0LCAnaWQnIHwgJ3RpbWVzdGFtcCc+KSA9PiB2b2lkXG4gIG1hcmtBbGVydFJlYWQ6IChpZDogc3RyaW5nKSA9PiB2b2lkXG4gIGNsZWFyQWxlcnRzOiAoKSA9PiB2b2lkXG4gIHNldFNjZW5hcmlvczogKHNjZW5hcmlvczogU2NlbmFyaW9bXSkgPT4gdm9pZFxuICBhY3RpdmF0ZVNjZW5hcmlvOiAoaWQ6IHN0cmluZykgPT4gdm9pZFxuICBkZWFjdGl2YXRlU2NlbmFyaW86IChpZDogc3RyaW5nKSA9PiB2b2lkXG5cbiAgLy8gTUwvQUkgYWN0aW9ucyAoUGhhc2UgMylcbiAgYWRkTUxQcmVkaWN0aW9uOiAocHJlZGljdGlvbjogTUxQcmVkaWN0aW9uKSA9PiB2b2lkXG4gIGFkZEFub21hbHk6IChhbm9tYWx5OiBBbm9tYWx5RXZlbnQpID0+IHZvaWRcbiAgYWRkQUlJbnNpZ2h0OiAoaW5zaWdodDogQUlJbnNpZ2h0KSA9PiB2b2lkXG4gIGFkZFNjZW5hcmlvQW5hbHlzaXM6IChhbmFseXNpczogU2NlbmFyaW9BbmFseXNpcykgPT4gdm9pZFxuICBzZXRDdWx0dXJhbEluc2lnaHRzOiAoaW5zaWdodHM6IEN1bHR1cmFsSW5zaWdodHMpID0+IHZvaWRcbiAgc2V0RWNvbm9taWNBbmFseXNpczogKGFuYWx5c2lzOiBFY29ub21pY0FuYWx5c2lzKSA9PiB2b2lkXG4gIGNsZWFyT2xkUHJlZGljdGlvbnM6ICgpID0+IHZvaWRcbiAgXG4gIC8vIFVJIGFjdGlvbnNcbiAgc2VsZWN0Um91dGU6IChpZDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZFxuICBzZWxlY3RWZWhpY2xlOiAoaWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWRcbiAgc2V0TWFwVmlldzogKGNlbnRlcjogW251bWJlciwgbnVtYmVyXSwgem9vbTogbnVtYmVyKSA9PiB2b2lkXG4gIHRvZ2dsZVNpZGViYXI6ICgpID0+IHZvaWRcbiAgc2V0QWN0aXZlUGFuZWw6IChwYW5lbDogQXBwU3RhdGVbJ2FjdGl2ZVBhbmVsJ10pID0+IHZvaWRcbiAgXG4gIC8vIENvbm5lY3Rpb24gYWN0aW9uc1xuICBzZXRDb25uZWN0aW9uU3RhdHVzOiAoc3RhdHVzOiBBcHBTdGF0ZVsnY29ubmVjdGlvblN0YXR1cyddKSA9PiB2b2lkXG4gIHVwZGF0ZUxhc3RVcGRhdGU6ICgpID0+IHZvaWRcblxuICAvLyBHVEZTIERhdGEgYWN0aW9uc1xuICBzZXRHVEZTRGF0YTogKGRhdGE6IEdURlNEYXRhKSA9PiB2b2lkXG4gIHNldEdURlNFcnJvcjogKGVycm9yOiBzdHJpbmcpID0+IHZvaWRcbiAgY2xlYXJHVEZTRGF0YTogKCkgPT4gdm9pZFxuXG4gIC8vIFByZWZlcmVuY2UgYWN0aW9uc1xuICBzZXRUaGVtZTogKHRoZW1lOiAnbGlnaHQnIHwgJ2RhcmsnKSA9PiB2b2lkXG4gIHRvZ2dsZU5vdGlmaWNhdGlvbnM6ICgpID0+IHZvaWRcbiAgc2V0QXV0b1JlZnJlc2g6IChlbmFibGVkOiBib29sZWFuKSA9PiB2b2lkXG4gIHNldFJlZnJlc2hJbnRlcnZhbDogKGludGVydmFsOiBudW1iZXIpID0+IHZvaWRcbn1cblxuLy8gRGVmYXVsdCBBY2NyYSBjb29yZGluYXRlc1xuY29uc3QgREVGQVVMVF9DRU5URVI6IFtudW1iZXIsIG51bWJlcl0gPSBbNS42MDM3LCAtMC4xODcwXVxuXG5leHBvcnQgY29uc3QgdXNlU3RvcmUgPSBjcmVhdGU8QXBwU3RhdGU+KCkoXG4gIHN1YnNjcmliZVdpdGhTZWxlY3Rvcigoc2V0LCBnZXQpID0+ICh7XG4gICAgLy8gSW5pdGlhbCBzdGF0ZVxuICAgIHZlaGljbGVzOiBbXSxcbiAgICByb3V0ZXM6IFtdLFxuICAgIHRyaXBzOiBbXSxcbiAgICBrcGlzOiBbXSxcblxuICAgIC8vIEdoYW5hIEdURlMgRGF0YVxuICAgIGd0ZnNEYXRhOiBudWxsLFxuICAgIGd0ZnNMb2FkZWQ6IGZhbHNlLFxuICAgIGd0ZnNFcnJvcjogbnVsbCxcbiAgICBhbGVydHM6IFtdLFxuICAgIHNjZW5hcmlvczogW10sXG5cbiAgICAvLyBNTC9BSSBpbml0aWFsIHN0YXRlIChQaGFzZSAzKVxuICAgIG1sUHJlZGljdGlvbnM6IFtdLFxuICAgIGFub21hbGllczogW10sXG4gICAgYWlJbnNpZ2h0czogW10sXG4gICAgc2NlbmFyaW9BbmFseXNlczogW10sXG4gICAgY3VsdHVyYWxJbnNpZ2h0czogbnVsbCxcbiAgICBlY29ub21pY0FuYWx5c2lzOiBudWxsLFxuICAgIFxuICAgIHNlbGVjdGVkUm91dGU6IG51bGwsXG4gICAgc2VsZWN0ZWRWZWhpY2xlOiBudWxsLFxuICAgIG1hcENlbnRlcjogREVGQVVMVF9DRU5URVIsXG4gICAgbWFwWm9vbTogMTIsXG4gICAgc2lkZWJhck9wZW46IHRydWUsXG4gICAgYWN0aXZlUGFuZWw6ICdvdmVydmlldycsXG4gICAgXG4gICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICBjb25uZWN0aW9uU3RhdHVzOiAnZGlzY29ubmVjdGVkJyxcbiAgICBsYXN0VXBkYXRlOiBudWxsLFxuICAgIFxuICAgIHRoZW1lOiAnbGlnaHQnLFxuICAgIG5vdGlmaWNhdGlvbnM6IHRydWUsXG4gICAgYXV0b1JlZnJlc2g6IHRydWUsXG4gICAgcmVmcmVzaEludGVydmFsOiAzMDAwMCwgLy8gMzAgc2Vjb25kc1xuICAgIFxuICAgIC8vIERhdGEgYWN0aW9uc1xuICAgIHNldFZlaGljbGVzOiAodmVoaWNsZXMpID0+IHNldCh7IHZlaGljbGVzIH0pLFxuICAgIFxuICAgIHVwZGF0ZVZlaGljbGU6IChpZCwgdXBkYXRlcykgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIHZlaGljbGVzOiBzdGF0ZS52ZWhpY2xlcy5tYXAodmVoaWNsZSA9PlxuICAgICAgICB2ZWhpY2xlLmlkID09PSBpZCA/IHsgLi4udmVoaWNsZSwgLi4udXBkYXRlcyB9IDogdmVoaWNsZVxuICAgICAgKVxuICAgIH0pKSxcbiAgICBcbiAgICBzZXRSb3V0ZXM6IChyb3V0ZXMpID0+IHNldCh7IHJvdXRlcyB9KSxcbiAgICBcbiAgICB1cGRhdGVSb3V0ZTogKGlkLCB1cGRhdGVzKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgcm91dGVzOiBzdGF0ZS5yb3V0ZXMubWFwKHJvdXRlID0+XG4gICAgICAgIHJvdXRlLmlkID09PSBpZCA/IHsgLi4ucm91dGUsIC4uLnVwZGF0ZXMgfSA6IHJvdXRlXG4gICAgICApXG4gICAgfSkpLFxuXG4gICAgc2V0VHJpcHM6ICh0cmlwcykgPT4gc2V0KHsgdHJpcHMgfSksXG5cbiAgICBzZXRLUElzOiAoa3BpcykgPT4gc2V0KHsga3BpcyB9KSxcbiAgICBcbiAgICB1cGRhdGVLUEk6IChpZCwgdXBkYXRlcykgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIGtwaXM6IHN0YXRlLmtwaXMubWFwKGtwaSA9PlxuICAgICAgICBrcGkuaWQgPT09IGlkID8geyAuLi5rcGksIC4uLnVwZGF0ZXMgfSA6IGtwaVxuICAgICAgKVxuICAgIH0pKSxcbiAgICBcbiAgICBhZGRBbGVydDogKGFsZXJ0KSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgYWxlcnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5hbGVydCxcbiAgICAgICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgfSxcbiAgICAgICAgLi4uc3RhdGUuYWxlcnRzXG4gICAgICBdXG4gICAgfSkpLFxuICAgIFxuICAgIG1hcmtBbGVydFJlYWQ6IChpZCkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIGFsZXJ0czogc3RhdGUuYWxlcnRzLm1hcChhbGVydCA9PlxuICAgICAgICBhbGVydC5pZCA9PT0gaWQgPyB7IC4uLmFsZXJ0LCByZWFkOiB0cnVlIH0gOiBhbGVydFxuICAgICAgKVxuICAgIH0pKSxcbiAgICBcbiAgICBjbGVhckFsZXJ0czogKCkgPT4gc2V0KHsgYWxlcnRzOiBbXSB9KSxcbiAgICBcbiAgICBzZXRTY2VuYXJpb3M6IChzY2VuYXJpb3MpID0+IHNldCh7IHNjZW5hcmlvcyB9KSxcbiAgICBcbiAgICBhY3RpdmF0ZVNjZW5hcmlvOiAoaWQpID0+IHNldCgoc3RhdGUpID0+ICh7XG4gICAgICBzY2VuYXJpb3M6IHN0YXRlLnNjZW5hcmlvcy5tYXAoc2NlbmFyaW8gPT5cbiAgICAgICAgc2NlbmFyaW8uaWQgPT09IGlkID8geyAuLi5zY2VuYXJpbywgYWN0aXZlOiB0cnVlIH0gOiBzY2VuYXJpb1xuICAgICAgKVxuICAgIH0pKSxcbiAgICBcbiAgICBkZWFjdGl2YXRlU2NlbmFyaW86IChpZCkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIHNjZW5hcmlvczogc3RhdGUuc2NlbmFyaW9zLm1hcChzY2VuYXJpbyA9PlxuICAgICAgICBzY2VuYXJpby5pZCA9PT0gaWQgPyB7IC4uLnNjZW5hcmlvLCBhY3RpdmU6IGZhbHNlIH0gOiBzY2VuYXJpb1xuICAgICAgKVxuICAgIH0pKSxcblxuICAgIC8vIE1ML0FJIGFjdGlvbnMgKFBoYXNlIDMpXG4gICAgYWRkTUxQcmVkaWN0aW9uOiAocHJlZGljdGlvbikgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIG1sUHJlZGljdGlvbnM6IFsuLi5zdGF0ZS5tbFByZWRpY3Rpb25zLnNsaWNlKC05OSksIHByZWRpY3Rpb25dIC8vIEtlZXAgbGFzdCAxMDBcbiAgICB9KSksXG5cbiAgICBhZGRBbm9tYWx5OiAoYW5vbWFseSkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIGFub21hbGllczogWy4uLnN0YXRlLmFub21hbGllcy5zbGljZSgtNDkpLCBhbm9tYWx5XSAvLyBLZWVwIGxhc3QgNTBcbiAgICB9KSksXG5cbiAgICBhZGRBSUluc2lnaHQ6IChpbnNpZ2h0KSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgYWlJbnNpZ2h0czogWy4uLnN0YXRlLmFpSW5zaWdodHMuc2xpY2UoLTI5KSwgaW5zaWdodF0gLy8gS2VlcCBsYXN0IDMwXG4gICAgfSkpLFxuXG4gICAgYWRkU2NlbmFyaW9BbmFseXNpczogKGFuYWx5c2lzKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgc2NlbmFyaW9BbmFseXNlczogWy4uLnN0YXRlLnNjZW5hcmlvQW5hbHlzZXMuc2xpY2UoLTE5KSwgYW5hbHlzaXNdIC8vIEtlZXAgbGFzdCAyMFxuICAgIH0pKSxcblxuICAgIHNldEN1bHR1cmFsSW5zaWdodHM6IChpbnNpZ2h0cykgPT4gc2V0KHsgY3VsdHVyYWxJbnNpZ2h0czogaW5zaWdodHMgfSksXG5cbiAgICBzZXRFY29ub21pY0FuYWx5c2lzOiAoYW5hbHlzaXMpID0+IHNldCh7IGVjb25vbWljQW5hbHlzaXM6IGFuYWx5c2lzIH0pLFxuXG4gICAgY2xlYXJPbGRQcmVkaWN0aW9uczogKCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3Qgb25lSG91ckFnbyA9IG5ldyBEYXRlKERhdGUubm93KCkgLSA2MCAqIDYwICogMTAwMClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1sUHJlZGljdGlvbnM6IHN0YXRlLm1sUHJlZGljdGlvbnMuZmlsdGVyKHAgPT4gcC50aW1lc3RhbXAgPiBvbmVIb3VyQWdvKSxcbiAgICAgICAgYW5vbWFsaWVzOiBzdGF0ZS5hbm9tYWxpZXMuZmlsdGVyKGEgPT4gYS5kZXRlY3RlZF9hdCA+IG9uZUhvdXJBZ28pXG4gICAgICB9XG4gICAgfSksXG4gICAgXG4gICAgLy8gVUkgYWN0aW9uc1xuICAgIHNlbGVjdFJvdXRlOiAoaWQpID0+IHNldCh7IHNlbGVjdGVkUm91dGU6IGlkIH0pLFxuICAgIHNlbGVjdFZlaGljbGU6IChpZCkgPT4gc2V0KHsgc2VsZWN0ZWRWZWhpY2xlOiBpZCB9KSxcbiAgICBzZXRNYXBWaWV3OiAoY2VudGVyLCB6b29tKSA9PiBzZXQoeyBtYXBDZW50ZXI6IGNlbnRlciwgbWFwWm9vbTogem9vbSB9KSxcbiAgICB0b2dnbGVTaWRlYmFyOiAoKSA9PiBzZXQoKHN0YXRlKSA9PiAoeyBzaWRlYmFyT3BlbjogIXN0YXRlLnNpZGViYXJPcGVuIH0pKSxcbiAgICBzZXRBY3RpdmVQYW5lbDogKHBhbmVsKSA9PiBzZXQoeyBhY3RpdmVQYW5lbDogcGFuZWwgfSksXG4gICAgXG4gICAgLy8gQ29ubmVjdGlvbiBhY3Rpb25zXG4gICAgc2V0Q29ubmVjdGlvblN0YXR1czogKHN0YXR1cykgPT4gc2V0KHsgXG4gICAgICBjb25uZWN0aW9uU3RhdHVzOiBzdGF0dXMsXG4gICAgICBjb25uZWN0ZWQ6IHN0YXR1cyA9PT0gJ2Nvbm5lY3RlZCdcbiAgICB9KSxcbiAgICBcbiAgICB1cGRhdGVMYXN0VXBkYXRlOiAoKSA9PiBzZXQoeyBsYXN0VXBkYXRlOiBuZXcgRGF0ZSgpIH0pLFxuXG4gICAgLy8gR1RGUyBEYXRhIGFjdGlvbnNcbiAgICBzZXRHVEZTRGF0YTogKGRhdGE6IEdURlNEYXRhKSA9PiBzZXQoeyBndGZzRGF0YTogZGF0YSwgZ3Rmc0xvYWRlZDogdHJ1ZSwgZ3Rmc0Vycm9yOiBudWxsIH0pLFxuICAgIHNldEdURlNFcnJvcjogKGVycm9yOiBzdHJpbmcpID0+IHNldCh7IGd0ZnNFcnJvcjogZXJyb3IsIGd0ZnNMb2FkZWQ6IGZhbHNlIH0pLFxuICAgIGNsZWFyR1RGU0RhdGE6ICgpID0+IHNldCh7IGd0ZnNEYXRhOiBudWxsLCBndGZzTG9hZGVkOiBmYWxzZSwgZ3Rmc0Vycm9yOiBudWxsIH0pLFxuXG4gICAgLy8gUHJlZmVyZW5jZSBhY3Rpb25zXG4gICAgc2V0VGhlbWU6ICh0aGVtZSkgPT4gc2V0KHsgdGhlbWUgfSksXG4gICAgdG9nZ2xlTm90aWZpY2F0aW9uczogKCkgPT4gc2V0KChzdGF0ZSkgPT4gKHsgbm90aWZpY2F0aW9uczogIXN0YXRlLm5vdGlmaWNhdGlvbnMgfSkpLFxuICAgIHNldEF1dG9SZWZyZXNoOiAoZW5hYmxlZCkgPT4gc2V0KHsgYXV0b1JlZnJlc2g6IGVuYWJsZWQgfSksXG4gICAgc2V0UmVmcmVzaEludGVydmFsOiAoaW50ZXJ2YWwpID0+IHNldCh7IHJlZnJlc2hJbnRlcnZhbDogaW50ZXJ2YWwgfSksXG4gIH0pKVxuKVxuXG4vLyBTZWxlY3RvcnMgZm9yIGNvbXB1dGVkIHZhbHVlc1xuZXhwb3J0IGNvbnN0IHVzZVVucmVhZEFsZXJ0cyA9ICgpID0+IHVzZVN0b3JlKChzdGF0ZSkgPT4gXG4gIHN0YXRlLmFsZXJ0cy5maWx0ZXIoYWxlcnQgPT4gIWFsZXJ0LnJlYWQpXG4pXG5cbmV4cG9ydCBjb25zdCB1c2VBY3RpdmVTY2VuYXJpb3MgPSAoKSA9PiB1c2VTdG9yZSgoc3RhdGUpID0+IFxuICBzdGF0ZS5zY2VuYXJpb3MuZmlsdGVyKHNjZW5hcmlvID0+IHNjZW5hcmlvLmFjdGl2ZSlcbilcblxuZXhwb3J0IGNvbnN0IHVzZVJvdXRlVmVoaWNsZXMgPSAocm91dGVJZDogc3RyaW5nKSA9PiB1c2VTdG9yZSgoc3RhdGUpID0+IFxuICBzdGF0ZS52ZWhpY2xlcy5maWx0ZXIodmVoaWNsZSA9PiB2ZWhpY2xlLnJvdXRlID09PSByb3V0ZUlkKVxuKVxuXG5leHBvcnQgY29uc3QgdXNlS1BJc0J5Q2F0ZWdvcnkgPSAoY2F0ZWdvcnk6IEtQSVsnY2F0ZWdvcnknXSkgPT4gdXNlU3RvcmUoKHN0YXRlKSA9PiBcbiAgc3RhdGUua3Bpcy5maWx0ZXIoa3BpID0+IGtwaS5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpXG4pXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwic3Vic2NyaWJlV2l0aFNlbGVjdG9yIiwiREVGQVVMVF9DRU5URVIiLCJ1c2VTdG9yZSIsInNldCIsImdldCIsInZlaGljbGVzIiwicm91dGVzIiwidHJpcHMiLCJrcGlzIiwiZ3Rmc0RhdGEiLCJndGZzTG9hZGVkIiwiZ3Rmc0Vycm9yIiwiYWxlcnRzIiwic2NlbmFyaW9zIiwibWxQcmVkaWN0aW9ucyIsImFub21hbGllcyIsImFpSW5zaWdodHMiLCJzY2VuYXJpb0FuYWx5c2VzIiwiY3VsdHVyYWxJbnNpZ2h0cyIsImVjb25vbWljQW5hbHlzaXMiLCJzZWxlY3RlZFJvdXRlIiwic2VsZWN0ZWRWZWhpY2xlIiwibWFwQ2VudGVyIiwibWFwWm9vbSIsInNpZGViYXJPcGVuIiwiYWN0aXZlUGFuZWwiLCJjb25uZWN0ZWQiLCJjb25uZWN0aW9uU3RhdHVzIiwibGFzdFVwZGF0ZSIsInRoZW1lIiwibm90aWZpY2F0aW9ucyIsImF1dG9SZWZyZXNoIiwicmVmcmVzaEludGVydmFsIiwic2V0VmVoaWNsZXMiLCJ1cGRhdGVWZWhpY2xlIiwiaWQiLCJ1cGRhdGVzIiwic3RhdGUiLCJtYXAiLCJ2ZWhpY2xlIiwic2V0Um91dGVzIiwidXBkYXRlUm91dGUiLCJyb3V0ZSIsInNldFRyaXBzIiwic2V0S1BJcyIsInVwZGF0ZUtQSSIsImtwaSIsImFkZEFsZXJ0IiwiYWxlcnQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibWFya0FsZXJ0UmVhZCIsInJlYWQiLCJjbGVhckFsZXJ0cyIsInNldFNjZW5hcmlvcyIsImFjdGl2YXRlU2NlbmFyaW8iLCJzY2VuYXJpbyIsImFjdGl2ZSIsImRlYWN0aXZhdGVTY2VuYXJpbyIsImFkZE1MUHJlZGljdGlvbiIsInByZWRpY3Rpb24iLCJzbGljZSIsImFkZEFub21hbHkiLCJhbm9tYWx5IiwiYWRkQUlJbnNpZ2h0IiwiaW5zaWdodCIsImFkZFNjZW5hcmlvQW5hbHlzaXMiLCJhbmFseXNpcyIsInNldEN1bHR1cmFsSW5zaWdodHMiLCJpbnNpZ2h0cyIsInNldEVjb25vbWljQW5hbHlzaXMiLCJjbGVhck9sZFByZWRpY3Rpb25zIiwib25lSG91ckFnbyIsIm5vdyIsImZpbHRlciIsInAiLCJhIiwiZGV0ZWN0ZWRfYXQiLCJzZWxlY3RSb3V0ZSIsInNlbGVjdFZlaGljbGUiLCJzZXRNYXBWaWV3IiwiY2VudGVyIiwiem9vbSIsInRvZ2dsZVNpZGViYXIiLCJzZXRBY3RpdmVQYW5lbCIsInBhbmVsIiwic2V0Q29ubmVjdGlvblN0YXR1cyIsInN0YXR1cyIsInVwZGF0ZUxhc3RVcGRhdGUiLCJzZXRHVEZTRGF0YSIsImRhdGEiLCJzZXRHVEZTRXJyb3IiLCJlcnJvciIsImNsZWFyR1RGU0RhdGEiLCJzZXRUaGVtZSIsInRvZ2dsZU5vdGlmaWNhdGlvbnMiLCJzZXRBdXRvUmVmcmVzaCIsImVuYWJsZWQiLCJzZXRSZWZyZXNoSW50ZXJ2YWwiLCJpbnRlcnZhbCIsInVzZVVucmVhZEFsZXJ0cyIsInVzZUFjdGl2ZVNjZW5hcmlvcyIsInVzZVJvdXRlVmVoaWNsZXMiLCJyb3V0ZUlkIiwidXNlS1BJc0J5Q2F0ZWdvcnkiLCJjYXRlZ29yeSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/useStore.ts\n"));

/***/ })

}]);